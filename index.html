<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lineup Builder - AA Fall Ball Coach</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton:wght@400&family=Roboto:wght@300;400;500;700&family=Russo+One&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <!-- Firebase Configuration -->
    <script>
        // Firebase configuration (real project) - Cache bust: 2025-09-27-03-45
        const firebaseConfig = {
            apiKey: "AIzaSyDJ275KTXKrczLuG0GsbMsTtOhSLAHZalU",
            authDomain: "lineup-builder-8aed6.firebaseapp.com",
            projectId: "lineup-builder-8aed6",
            storageBucket: "lineup-builder-8aed6.firebasestorage.app",
            messagingSenderId: "30919872647",
            appId: "1:30919872647:web:8fbed0f93768b228d26822"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        
        // Enable offline persistence
        db.enablePersistence().catch((err) => {
            if (err.code == 'failed-precondition') {
                console.log('Multiple tabs open, persistence can only be enabled in one tab at a time.');
            } else if (err.code == 'unimplemented') {
                console.log('The current browser does not support all features required for persistence');
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        /* Sports-style typography */
        .sports-title {
            font-family: 'Russo One', 'Anton', 'Arial Black', sans-serif;
            font-weight: 400;
            color: #BD3039;
            -webkit-text-stroke: 2px white;
            text-stroke: 2px white;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            letter-spacing: 1px;
        }
        
        .sports-heading {
            font-family: 'Orbitron', 'Russo One', sans-serif;
            font-weight: 700;
            color: #0C2340;
            -webkit-text-stroke: 1px white;
            text-stroke: 1px white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 0.5px;
        }
        
        .sports-subheading {
            font-family: 'Orbitron', sans-serif;
            font-weight: 400;
            color: #BD3039;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, #0C2340, #BD3039);
            color: white;
            padding: 20px 0;
            margin-bottom: 30px;
            border-radius: 10px;
            text-align: center;
        }
        
        h1 {
            font-family: 'Anton', sans-serif;
            font-size: 2.5rem;
            font-weight: 400;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        
        h2 {
            font-family: 'Anton', sans-serif;
            color: #0C2340;
            font-weight: 400;
            letter-spacing: 1px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .nav button {
            background: white;
            color: #0C2340;
            border: 2px solid #0C2340;
            padding: 18px 36px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Anton', sans-serif;
            font-weight: 400;
            font-size: 16px;
            letter-spacing: 1px;
            transition: all 0.3s;
            min-width: 140px;
            text-align: center;
        }
        
        .nav button:hover, .nav button.active {
            background: #0C2340;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(12, 35, 64, 0.3);
        }
        
        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #2563eb;
        }
        
        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #64748b;
            font-weight: 500;
        }
        
        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .player-card {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s;
        }
        
        .player-card:hover {
            border-color: #2563eb;
            transform: translateY(-2px);
        }
        
        .player-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #1e293b;
            margin-bottom: 10px;
        }
        
        .position-badges {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .badge-pitcher { background: #dbeafe; color: #1e40af; }
        .badge-catcher { background: #f3e8ff; color: #7c3aed; }
        .badge-infield { background: #fef2f2; color: #991b1b; }
        .badge-outfield { background: #f0fdf4; color: #166534; }
        
        .btn {
            background: #BD3039;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Anton', sans-serif;
            font-weight: 400;
            font-size: 14px;
            letter-spacing: 1px;
            transition: all 0.3s;
            margin: 5px;
        }
        
        .btn:hover {
            background: #A02830;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: #0C2340;
        }
        
        .btn-secondary:hover {
            background: #1a3a5c;
        }
        
        .hidden {
            display: none;
        }
        
        .lineup-display {
            background: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .inning {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #2563eb;
        }
        
        .position-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .position-row:last-child {
            border-bottom: none;
        }
        
        .position {
            font-weight: bold;
            color: #2563eb;
            min-width: 30px;
        }
        
        .player {
            flex: 1;
            margin-left: 15px;
        }
        
        .player-form {
            background: #f8fafc;
            border: 2px dashed #cbd5e1;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #374151;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .position-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .position-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .position-checkbox input[type="checkbox"] {
            width: auto;
        }
        
        .player-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        .btn-danger {
            background: #dc2626;
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        .btn-success {
            background: #BD3039;
        }
        
        .btn-success:hover {
            background: #A02830;
        }
        
        .editing {
            border-color: #2563eb !important;
            background: #eff6ff !important;
        }
        
        .lineup-section {
            margin-bottom: 15px;
        }
        
        .bench-section {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .bench-section h5 {
            margin: 0 0 8px 0;
            color: #92400e;
            font-size: 0.9rem;
        }
        
        .bench-player {
            display: inline-block;
            background: #fbbf24;
            color: #92400e;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 2px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        
        .rules-container {
            margin-top: 20px;
        }
        
        .rule-category {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .rule-category h3 {
            color: #2563eb;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }
        
        .rule-category ol {
            margin-left: 20px;
        }
        
        .rule-category li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .rule-category strong {
            color: #1e40af;
        }
        
        .player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .player-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
        }
        
        .player-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .player-info h4 {
            margin: 0 0 8px 0;
            color: #1e40af;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .player-info p {
            margin: 0;
            color: #6b7280;
            font-size: 0.9rem;
        }
        
        .badge {
            display: inline-block !important;
            padding: 6px 12px !important;
            border-radius: 8px !important;
            font-size: 0.8rem !important;
            font-weight: 800 !important;
            text-transform: uppercase !important;
            margin-left: 10px !important;
            border: 2px solid !important;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2) !important;
        }
        
        .badge.pitcher {
            background: #ffd700 !important;
            color: #000000 !important;
            border-color: #ff8c00 !important;
        }
        
        .badge.catcher {
            background: #00bfff !important;
            color: #ffffff !important;
            border-color: #0066cc !important;
        }
        
        /* Cache busting - badges should be visible now */
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.875rem;
        }
        
        .btn-danger {
            background: #dc2626;
            color: white;
            border: none;
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        /* Batting Order Styles */
        .batting-order-section {
            margin-bottom: 20px;
        }
        
        .batting-order-section h4 {
            margin-bottom: 10px;
            color: #2563eb;
        }
        
        .player-list, .batting-order-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 60px;
            padding: 15px;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            background: #f8fafc;
        }
        
        .batting-order-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .player-item {
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: move;
            user-select: none;
            transition: all 0.2s ease;
            font-weight: 600;
            text-align: center;
            min-width: 80px;
        }
        
        .player-item:hover {
            border-color: #2563eb;
            background: #eff6ff;
        }
        
        .player-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .batting-slot {
            background: #f3f4f6;
            border: 2px dashed #9ca3af;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .batting-slot.drag-over {
            border-color: #2563eb;
            background: #eff6ff;
        }
        
        .batting-slot.occupied {
            border-style: solid;
            border-color: #10b981;
            background: #ecfdf5;
        }
        
        .batting-slot-number {
            font-size: 0.8rem;
            color: #6b7280;
            margin-bottom: 5px;
        }
        
        .batting-order-actions {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        /* Print Styles */
        @media print {
            .nav, .btn, .player-form, .batting-order-actions {
                display: none !important;
            }
            
            .lineup-card {
                page-break-inside: avoid;
                margin-bottom: 20px;
            }
            
            body {
                font-size: 12px;
                line-height: 1.4;
            }
        }
        
        /* Game Stats Interface Styles */
        .game-stats-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .game-stats-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .game-stats-header {
            background: linear-gradient(135deg, #BD3039, #0C2340);
            color: white;
            padding: 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-stats-header h2 {
            margin: 0;
            font-family: 'Russo One', sans-serif;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .close-stats-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-stats-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .scoreboard {
            background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .scoreboard-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .score-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }
        
        .team-score {
            text-align: center;
        }
        
        .score-number {
            font-size: 48px;
            font-weight: bold;
            font-family: 'Orbitron', monospace;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .team-name {
            font-size: 16px;
            font-weight: 500;
            margin-top: 5px;
            opacity: 0.9;
        }
        
        .vs {
            font-size: 24px;
            font-weight: bold;
            opacity: 0.7;
        }
        
        .game-info {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 16px;
            font-weight: 500;
        }
        
        .game-info span {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .stats-controls {
            padding: 20px;
        }
        
        .player-selectors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .player-selector {
            display: flex;
            flex-direction: column;
        }
        
        .player-selector label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }
        
        .player-selector select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        
        .player-selector select:focus {
            outline: none;
            border-color: #BD3039;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .action-btn {
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-hit {
            background: #10b981;
            color: white;
        }
        
        .btn-out {
            background: #ef4444;
            color: white;
        }
        
        .btn-walk {
            background: #3b82f6;
            color: white;
        }
        
        .btn-pitch {
            background: #8b5cf6;
            color: white;
        }
        
        .btn-start {
            background: #f59e0b;
            color: white;
            grid-column: 1 / -1;
            padding: 16px;
            font-size: 16px;
        }
        
        .pitcher-stats {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .pitcher-stats h4 {
            margin: 0 0 10px 0;
            color: #0c4a6e;
            font-family: 'Orbitron', sans-serif;
        }
        
        .pitcher-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .stat-item {
            text-align: center;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #111827;
        }
        
        @media (max-width: 768px) {
            .game-stats-content {
                width: 95%;
                margin: 10px;
            }
            
            .score-display {
                gap: 20px;
            }
            
            .score-number {
                font-size: 36px;
            }
            
            .game-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .player-selectors {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
  </head>
  <body>
    <div class="container">
        <header>
            <h1 class="sports-title">⚾ LINEUP BUILDER</h1>
            <p class="subtitle sports-subheading">AA Fall Ball Coach Admin App</p>
            <button id="logoutBtn" onclick="logout()" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: 2px solid white; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold;">Logout</button>
        </header>
        
        <nav class="nav">
            <button class="active" onclick="showSection('dashboard')">Dashboard</button>
            <button onclick="showSection('players')">Players</button>
            <button onclick="showSection('schedule')">Schedule</button>
            <button onclick="showSection('rules')">Rules & Constraints</button>
            <button onclick="showSection('seasonStats')">Season Stats</button>
        </nav>
        
        <!-- Dashboard Section -->
        <div id="dashboard" class="section">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalPlayers">0</div>
                    <div class="stat-label">Total Players</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalPitchers">0</div>
                    <div class="stat-label">Pitchers</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalCatchers">0</div>
                    <div class="stat-label">Catchers</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalWins">0</div>
                    <div class="stat-label">Wins</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalLosses">0</div>
                    <div class="stat-label">Losses</div>
                </div>
            </div>
            
            <!-- Data Sync Section -->
            <div class="card" style="margin-top: 20px;">
                <h3 class="sports-subheading">☁️ Cloud Sync & Data Transfer</h3>
                <p style="margin-bottom: 15px; color: #6b7280;">Your data is automatically synced to the cloud! Multiple coaches can use the same team code to collaborate in real-time.</p>
                
                <div id="syncStatus" style="margin-bottom: 15px; padding: 10px; background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; font-size: 14px;">
                    <strong>🔄 Cloud Sync:</strong> <span id="syncStatusText">Connecting...</span>
                </div>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn" onclick="exportTeamData()" style="background: #10b981; color: white; border: 2px solid #10b981;">
                        📤 Export Team Data
                    </button>
                    <button class="btn" onclick="importTeamData()" style="background: #3b82f6; color: white; border: 2px solid #3b82f6;">
                        📥 Import Team Data
                    </button>
                    <button class="btn" onclick="forceSync()" style="background: #f59e0b; color: white; border: 2px solid #f59e0b;">
                        🔄 Force Sync Now
                    </button>
                    <button class="btn" onclick="recoverData()" style="background: #dc2626; color: white; border: 2px solid #dc2626;">
                        🚨 Recover Data
                    </button>
                    <button class="btn" onclick="enableSafeMode()" style="background: #7c3aed; color: white; border: 2px solid #7c3aed;">
                        🛡️ Safe Mode (Local Only)
                    </button>
                    <button class="btn" onclick="resetToDefault()" style="background: #ef4444; color: white; border: 2px solid #ef4444;">
                        🔄 Reset to Default
                    </button>
                    <button class="btn" onclick="restorePlayers()" style="background: #f59e0b; color: white; border: 2px solid #f59e0b;">
                        🔄 Restore Players
                    </button>
                </div>
                
                <div style="margin-top: 15px; padding: 12px; background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 6px; font-size: 14px;">
                    <strong>💡 How to sync:</strong><br>
                    1. Click "Export Team Data" on your desktop → Download file<br>
                    2. Transfer file to mobile (email, AirDrop, etc.)<br>
                    3. Click "Import Team Data" on mobile → Upload file<br>
                    4. All your players, games, and stats will sync! ✨
                </div>
            </div>
            
            <!-- Season Player Stats Section -->
            <div class="card" style="margin-top: 20px;">
                <h3 class="sports-subheading">📊 Season Player Statistics</h3>
                <p style="margin-bottom: 15px; color: #6b7280;">Track detailed stats for each player across all games.</p>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                    <button class="btn" onclick="showPitcherStats()" style="background: #dc2626; color: white; border: 2px solid #dc2626;">
                        🎯 Pitcher Stats
                    </button>
                    <button class="btn" onclick="showBatterStats()" style="background: #059669; color: white; border: 2px solid #059669;">
                        ⚾ Batter Stats
                    </button>
                </div>
                
                <div id="playerStatsContent">
                    <p style="color: #6b7280; text-align: center; padding: 20px;">Click a button above to view detailed player statistics</p>
                </div>
            </div>
            
        </div>
        
        <!-- Players Section -->
        <div id="players" class="section hidden">
            <div class="card">
                <h2 class="sports-heading">TEAM ROSTER</h2>
                
                <!-- Add Player Form -->
                <div class="player-form">
                    <h3>Add New Player</h3>
                    <div class="form-group">
                        <label>Player Name:</label>
                        <input type="text" id="playerName" placeholder="Enter player name">
                    </div>
                    
                    
                    <div class="form-group">
                        <label>Available Positions (uncheck positions they can't/won't play):</label>
                        <div class="position-checkboxes">
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-All" checked onchange="toggleAllPositions()">
                                <label for="pos-All" style="font-weight: bold; color: #2563eb;">All</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-P" checked onchange="updateAllCheckbox()">
                                <label for="pos-P">P</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-C" checked onchange="updateAllCheckbox()">
                                <label for="pos-C">C</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-1B" checked onchange="updateAllCheckbox()">
                                <label for="pos-1B">1B</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-2B" checked onchange="updateAllCheckbox()">
                                <label for="pos-2B">2B</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-SS" checked onchange="updateAllCheckbox()">
                                <label for="pos-SS">SS</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-3B" checked onchange="updateAllCheckbox()">
                                <label for="pos-3B">3B</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-LF" checked onchange="updateAllCheckbox()">
                                <label for="pos-LF">LF</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-CF" checked onchange="updateAllCheckbox()">
                                <label for="pos-CF">CF</label>
                            </div>
                            <div class="position-checkbox">
                                <input type="checkbox" id="pos-RF" checked onchange="updateAllCheckbox()">
                                <label for="pos-RF">RF</label>
                            </div>
                        </div>
                    </div>
                    
                    <div class="player-actions">
                        <button class="btn btn-success" id="addEditButton" onclick="addPlayer()">Add Player</button>
                        <button class="btn btn-secondary" onclick="clearForm()">Clear Form</button>
                    </div>
                </div>
                
                <!-- Player List -->
                <div id="playerList" class="player-grid">
                    <!-- Players will be dynamically added here -->
                </div>
            </div>
        </div>
        
        <!-- Schedule Section -->
        <div id="schedule" class="section hidden">
            <div class="card">
                <h2 class="sports-heading">GAME SCHEDULE</h2>
                <p>Click on any game to manage lineups, batting order, and player availability.</p>
                
                <!-- Add New Game Button -->
                <div style="margin-bottom: 20px; text-align: center;">
                    <button class="btn btn-success" onclick="showAddGameForm()" id="showAddGameBtn">+ Add New Game</button>                                                                                             
                </div>
                
                <!-- Generate Future Lineups Button -->
                <div style="margin-bottom: 30px; text-align: center;">
                    <button class="btn" onclick="generateFutureLineups()" style="background: #7c3aed; color: white; border: 2px solid #7c3aed; font-family: 'Orbitron', sans-serif; font-size: 14px; letter-spacing: 0.5px;">🔮 GENERATE FUTURE LINEUPS</button>
                    <p style="margin-top: 8px; color: #6b7280; font-size: 0.9rem;">Regenerate lineups for all future games based on current player capabilities</p>
                </div>
                
                <!-- Add New Game Form (Hidden by default) -->
                <div class="player-form" style="margin-bottom: 30px; display: none;" id="addGameForm">
                    <h3>Add New Game</h3>
                    
                    <div class="form-group">
                        <label>Opponent:</label>
                        <input type="text" id="gameOpponent" placeholder="Enter opponent team name">
                    </div>
                    
                    <div class="form-group">
                        <label>Date:</label>
                        <input type="date" id="gameDate">
                    </div>
                    
                    <div class="form-group">
                        <label>Innings:</label>
                        <select id="gameInnings">
                            <option value="5">5 innings</option>
                            <option value="6" selected>6 innings</option>
                            <option value="7">7 innings</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Final Score (optional):</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="ourScore" placeholder="Our Score" min="0" style="width: 100px;">
                            <span>-</span>
                            <input type="number" id="opponentScore" placeholder="Opponent Score" min="0" style="width: 100px;">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Available Players (check players who will be at this game):</label>
                        <div id="gamePlayerCheckboxes" class="position-checkboxes">
                            <!-- Player checkboxes will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="player-actions">
                        <button class="btn btn-success" onclick="addGame()">Add Game</button>
                        <button class="btn btn-secondary" onclick="hideAddGameForm()">Cancel</button>
                    </div>
                </div>
                
                <!-- Games List -->
                <div id="gamesList">
                    <!-- Games will be populated by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Game Detail Section -->
        <div id="gameDetail" class="section hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 id="gameDetailTitle">Game Details</h2>
                    <button class="btn btn-secondary" onclick="goBackToSchedule()">← Back to Schedule</button>
                </div>
                
                <!-- Game Info -->
                <div id="gameInfo" class="card" style="background: #f8fafc; margin-bottom: 20px;">
                    <!-- Game info will be populated by JavaScript -->
                </div>
                
                <!-- Game Editing Form -->
                <div class="card" style="margin-bottom: 20px;">
                    <h3>Edit Game Details</h3>
                    <div class="player-form">
                        <div class="form-group">
                            <label>Opponent:</label>
                            <input type="text" id="editGameOpponent" placeholder="Enter opponent team name">
                        </div>
                        
                        <div class="form-group">
                            <label>Date:</label>
                            <input type="date" id="editGameDate">
                        </div>
                        
                        <div class="form-group">
                            <label>Innings:</label>
                            <select id="editGameInnings">
                                <option value="5">5 innings</option>
                                <option value="6" selected>6 innings</option>
                                <option value="7">7 innings</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Final Score (optional):</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="editOurScore" placeholder="Our Score" min="0" style="width: 100px;">
                                <span>-</span>
                                <input type="number" id="editOpponentScore" placeholder="Opponent Score" min="0" style="width: 100px;">
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>Available Players (check players who will be at this game):</label>
                            <div id="editGamePlayerCheckboxes" class="position-checkboxes">
                                <!-- Player checkboxes will be populated by JavaScript -->
                            </div>
                        </div>
                        
                        <div class="player-actions">
                            <button class="btn btn-success" onclick="updateGameFromDetail()">Save</button>
                            <button class="btn btn-danger" onclick="deleteGameFromDetail()">Delete Game</button>
                        </div>
                    </div>
                </div>
                
                <!-- Defensive Lineup Management -->
                <div class="card" style="margin-bottom: 20px;">
                    <h3>Defensive Lineup</h3>
                    <p>Generate and manage defensive position rotations for this game.</p>
                    <!-- Manual Pitcher Selection -->
                    <div class="manual-pitcher-section" style="margin-bottom: 15px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
                        <label style="display: flex; align-items: center; margin-bottom: 10px; font-weight: bold;">
                            <input type="checkbox" id="manualPitcherToggle" onchange="toggleManualPitcherSelection()" style="margin-right: 8px;">
                            Manual Pitcher Selection
                        </label>
                        <div id="manualPitcherControls" style="display: none;">
                            <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">Select pitchers for each inning (leave blank for automatic selection):</p>
                            <div id="pitcherDropdowns" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <!-- Pitcher dropdowns will be generated here -->
                            </div>
                            <div id="pitcherValidation" style="margin-top: 10px; font-size: 14px;"></div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                        <button class="btn" onclick="console.log('Button clicked!'); generateLineupForCurrentGame();" id="generateLineupBtn" style="background: #BD3039; color: white; border: 2px solid #BD3039; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: bold; z-index: 1000; position: relative; font-family: 'Orbitron', sans-serif; font-size: 16px; letter-spacing: 0.5px;">GENERATE DEFENSIVE LINEUP</button>
                        <button class="btn btn-secondary" onclick="viewSavedLineupForCurrentGame()">View Saved Lineup</button>
                        <button class="btn" onclick="printLineupCardForCurrentGame()">Print Lineup Card</button>
                    </div>
                    <div id="lineup-display" class="lineup-display">
                        <p style="color: #6b7280;">Click "Generate Defensive Lineup" to create position rotations for this game.</p>
                    </div>
                </div>
                
                <!-- Batting Order Management -->
                <div class="card">
                    <h3>Batting Order</h3>
                    <p>Drag and drop to create the batting order for this game.</p>
                    
                    <div id="battingOrderContainer">
                        <div class="batting-order-section">
                            <h4>Available Players</h4>
                            <div id="availablePlayers" class="player-list">
                                <!-- Available players will be populated here -->
                            </div>
                        </div>
                        
                        <div class="batting-order-section">
                            <h4 id="battingOrderTitle">Batting Order</h4>
                            <div id="battingOrder" class="batting-order-list">
                                <!-- Batting order slots will be populated here -->
                            </div>
                        </div>
                        
                        <div class="batting-order-actions">
                            <button class="btn" onclick="saveBattingOrder()">Save Batting Order</button>
                            <button class="btn btn-secondary" onclick="autoGenerateBattingOrder()">Auto-Generate Order</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        
        <!-- Rules & Constraints Section -->
        <div id="rules" class="section hidden">
            <div class="card">
                <h2 class="sports-heading">LINEUP GENERATION RULES & CONSTRAINTS</h2>
                <p>These rules are applied in priority order to create fair and balanced lineups.</p>
                
                <div class="rules-container">
                    <div class="rule-category">
                        <h3>🎯 Core Principles</h3>
                        <ol>
                            <li><strong>All positions must be filled</strong> - Every inning has all positions filled (8 players = 8 positions, 9+ players = 9 positions)</li>                                                    
                            <li><strong>No duplicate players per inning</strong> - Each player can only play one position per inning</li>                                                                               
                            <li><strong>Respect player availability</strong> - Only use players marked as available for the game</li>                                                                                   
                            <li><strong>Respect position exclusions</strong> - Never put players in positions they've excluded</li>                                                                                     
                            <li><strong>Randomized selection</strong> - Player list is shuffled to avoid bias in selection order</li>                                                                                   
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>⚾ Pitching Rules</h3>
                        <ol>
                            <li><strong>Maximum 2 innings per pitcher</strong> - No pitcher throws more than 2 innings</li>
                            <li><strong>Prefer 6 different pitchers</strong> - Try to have 6 different kids pitch 1 inning each</li>
                            <li><strong>Consecutive innings allowed</strong> - If needed, pitchers can throw 2 consecutive innings</li>
                            <li><strong>Designated pitchers preferred</strong> - Use players marked as pitchers (P) first</li>
                            <li><strong>Fallback to any player</strong> - If no designated pitchers available, any player can pitch</li>
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>🥎 Catching Rules</h3>
                        <ol>
                            <li><strong>Maximum 2 innings per catcher</strong> - No catcher catches more than 2 innings</li>
                            <li><strong>No consecutive innings</strong> - Catchers cannot catch consecutive innings</li>
                            <li><strong>Designated catchers preferred</strong> - Use players marked as catchers (C) first</li>
                            <li><strong>Fallback to any player</strong> - If no designated catchers available, any player can catch</li>
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>🏃‍♂️ Playing Time Balance</h3>
                        <ol>
                            <li><strong>Equal total playing time</strong> - All players get similar total innings on the field</li>
                            <li><strong>Infield/Outfield balance</strong> - P and C count as "infield" for balance calculations</li>
                            <li><strong>Target balance ratios</strong> - Algorithm aims for equitable infield vs outfield time per player</li>
                            <li><strong>No consecutive outfield</strong> - Prefer players who didn't play outfield last inning</li>
                            <li><strong>Position variety allowed</strong> - Players can play multiple positions (no 1-inning-per-position limit)</li>
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>🪑 Bench Management</h3>
                        <ol>
                            <li><strong>Dynamic bench calculation</strong> - Bench time calculated based on number of available players</li>                                                                            
                            <li><strong>8 players = no bench</strong> - Perfect setup: 8 players, 8 positions (P, C, 1B, 2B, SS, 3B, LF, RF)</li>                                                                          
                            <li><strong>9 players = no bench</strong> - Perfect setup: 9 players, 9 positions, everyone plays all innings</li>                                                                          
                            <li><strong>10+ players = bench time</strong> - Balanced bench rotation with fair distribution</li>                                                                                         
                            <li><strong>Fair bench distribution</strong> - No player sits 3 innings while others sit only 1</li>                                                                                        
                            <li><strong>Catcher availability priority</strong> - Ensure at least one catcher is always available</li>                                                                                   
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>🔄 Selection Priority Order</h3>
                        <ol>
                            <li><strong>Pitcher selection:</strong> New pitchers → Consecutive pitchers → Any designated pitcher → Any player</li>
                            <li><strong>Catcher selection:</strong> Designated catchers (non-consecutive) → Any player (non-consecutive)</li>
                            <li><strong>Infield positions (1B, 2B, SS, 3B):</strong> Players with least infield time → Players with least total time</li>
                            <li><strong>Outfield positions (LF, RF for 8 players; LF, CF, RF for 9+ players):</strong> Players who didn't play outfield last inning → Players with least outfield time</li>
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>📊 Algorithm Features</h3>
                        <ol>
                            <li><strong>Advanced scoring system</strong> - Multi-factor scoring for player selection</li>
                            <li><strong>Usage tracking</strong> - Tracks pitcher, catcher, infield, outfield, and total usage per player</li>
                            <li><strong>Last position tracking</strong> - Remembers last outfield inning to prevent consecutive assignments</li>
                            <li><strong>Dynamic target calculation</strong> - Balances targets adjust based on number of players and innings</li>
                            <li><strong>Robust fallback logic</strong> - Multiple fallback strategies if primary selection fails</li>
                        </ol>
                    </div>
                    
                    <div class="rule-category">
                        <h3>🎲 Randomization & Fairness</h3>
                        <ol>
                            <li><strong>Player list shuffling</strong> - Randomizes player order at start to prevent bias</li>
                            <li><strong>No fixed patterns</strong> - Same player won't always be benched first</li>
                            <li><strong>Balanced selection</strong> - Algorithm considers multiple factors for fair distribution</li>
                            <li><strong>Consistent results</strong> - Same inputs produce same lineup (deterministic after shuffle)</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Season Stats Section -->
        <div id="seasonStats" class="section hidden">
            <div class="card">
                <h2 class="sports-heading">SEASON STATISTICS</h2>
                <p>Track cumulative playing time and identify imbalances across all games.</p>
                
                <div style="margin-bottom: 20px;">
                    <button class="btn" onclick="rebuildSeasonStats()" style="background: #2563eb; color: white; margin-right: 10px;">🔄 Rebuild from Saved Lineups</button>                                                               
                    <button class="btn btn-secondary" onclick="clearSeasonStats()" style="background: #dc2626; color: white;">🗑️ Clear Season Stats</button>                                                             
                </div>
                
                <div id="seasonStatsContent">
                    <p style="color: #6b7280;">No games played yet. Generate lineups to see season statistics.</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Test function to verify JavaScript is loading
        function testJS() {
            console.log('JavaScript is loading correctly');
            return true;
        }
        
        // Game Stats Data Structures
        let gameStats = {
            currentInning: 1,
            currentOuts: 0,
            homeScore: 0,
            awayScore: 0,
            isHomeTeam: true,
            gameStatus: 'scheduled', // 'scheduled', 'in-progress', 'completed'
            currentBatter: null,
            currentPitcher: null,
            innings: [],
            pitchers: [],
            batters: []
        };
        
        // Season-long persistent stats
        let seasonPlayerStats = {
            pitchers: {}, // playerId -> { totalPitches, strikes, balls, hitsAllowed, runsAllowed, strikeouts, walks }
            batters: {}   // playerId -> { atBats, hits, singles, doubles, triples, homeRuns, strikeouts, walks, stolenBases, rbi, runs }
        };
        
        // Safe mode flag to disable Firebase sync
        let safeMode = false;
        
        // Emergency debugging
        function emergencyDebug() {
            console.log('🚨 EMERGENCY DEBUG INFO:');
            console.log('Safe Mode:', safeMode);
            console.log('Players:', players.length, players);
            console.log('Games:', games.length, games);
            console.log('Current Team Code:', currentTeamCode);
            console.log('Local Storage Keys:', Object.keys(localStorage).filter(k => k.includes('lineupBuilder')));
            
            // Check for any Firebase listeners still running
            console.log('Firebase listeners active:', window.firebaseListeners || 'none');
            
            // Check localStorage data
            const localPlayers = localStorage.getItem(getStorageKey('players'));
            console.log('Local Storage Players:', localPlayers ? JSON.parse(localPlayers).length : 'none');
            
            // Check if any functions are modifying players array
            console.log('Players array reference:', players);
        }
        
        // Add player array protection
        let originalPlayers = [];
        function protectPlayerArray() {
            originalPlayers = [...players];
            console.log('Protected players array:', originalPlayers.length);
        }
        
        function checkPlayerArray() {
            if (players.length !== originalPlayers.length) {
                console.error('🚨 PLAYER ARRAY MODIFIED!');
                console.error('Original length:', originalPlayers.length);
                console.error('Current length:', players.length);
                console.error('Original players:', originalPlayers);
                console.error('Current players:', players);
                
                // Restore from backup
                players = [...originalPlayers];
                console.log('Restored players array');
                renderPlayers();
            }
        }
        
        // Add emergency debug button
        function addEmergencyDebugButton() {
            const debugBtn = document.createElement('button');
            debugBtn.innerHTML = '🚨 Debug';
            debugBtn.style.cssText = 'position: fixed; top: 10px; right: 10px; z-index: 10000; background: red; color: white; padding: 5px; border: none; border-radius: 3px;';
            debugBtn.onclick = emergencyDebug;
            document.body.appendChild(debugBtn);
        }
        
        // Load season player stats from localStorage
        function loadSeasonPlayerStats() {
            const saved = localStorage.getItem(getStorageKey('seasonPlayerStats'));
            if (saved) {
                seasonPlayerStats = JSON.parse(saved);
            }
        }
        
        // Save season player stats to localStorage
        async function saveSeasonPlayerStats() {
            localStorage.setItem(getStorageKey('seasonPlayerStats'), JSON.stringify(seasonPlayerStats));
            if (!safeMode) {
                await saveToFirebase(); // Also save to cloud
            }
        }
        
        // Initialize player stats if they don't exist
        function initializePlayerStats(playerId) {
            if (!seasonPlayerStats.pitchers[playerId]) {
                seasonPlayerStats.pitchers[playerId] = {
                    totalPitches: 0,
                    strikes: 0,
                    balls: 0,
                    hitsAllowed: 0,
                    runsAllowed: 0,
                    strikeouts: 0,
                    walks: 0,
                    inningsPitched: 0
                };
            }
            if (!seasonPlayerStats.batters[playerId]) {
                seasonPlayerStats.batters[playerId] = {
                    atBats: 0,
                    hits: 0,
                    singles: 0,
                    doubles: 0,
                    triples: 0,
                    homeRuns: 0,
                    strikeouts: 0,
                    walks: 0,
                    stolenBases: 0,
                    rbi: 0,
                    runs: 0
                };
            }
        }
        
        // Initialize game stats for a game
        function initializeGameStats(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;
            
            // Initialize innings
            gameStats.innings = Array.from({ length: 9 }, (_, i) => ({
                inning: i + 1,
                homeRuns: 0,
                awayRuns: 0,
                homeHits: 0,
                awayHits: 0,
                homeErrors: 0,
                awayErrors: 0,
                isComplete: false
            }));
            
            // Initialize pitchers (mock detection - in real app, use player positions)
            gameStats.pitchers = game.availablePlayers
                .map(playerId => {
                    const player = players.find(p => p.id === playerId);
                    return player ? {
                        playerId: player.id,
                        playerName: player.name,
                        inningsPitched: 0,
                        pitchesThrown: 0,
                        strikeouts: 0,
                        walks: 0,
                        hitsAllowed: 0,
                        runsAllowed: 0,
                        earnedRuns: 0,
                        isCurrentPitcher: false
                    } : null;
                })
                .filter(p => p !== null)
                .slice(0, 6); // Limit to 6 pitchers
            
            // Initialize batters
            gameStats.batters = game.availablePlayers
                .map(playerId => {
                    const player = players.find(p => p.id === playerId);
                    return player ? {
                        playerId: player.id,
                        playerName: player.name,
                        atBats: 0,
                        hits: 0,
                        singles: 0,
                        doubles: 0,
                        triples: 0,
                        homeRuns: 0,
                        rbi: 0,
                        runs: 0,
                        walks: 0,
                        strikeouts: 0,
                        stolenBases: 0
                    } : null;
                })
                .filter(p => p !== null);
            
            // Set current pitcher and batter
            if (gameStats.pitchers.length > 0) {
                gameStats.pitchers[0].isCurrentPitcher = true;
                gameStats.currentPitcher = gameStats.pitchers[0].playerId;
            }
            
            if (gameStats.batters.length > 0) {
                gameStats.currentBatter = gameStats.batters[0].playerId;
            }
            
            // Reset game state
            gameStats.currentInning = 1;
            gameStats.currentOuts = 0;
            gameStats.homeScore = 0;
            gameStats.awayScore = 0;
            gameStats.gameStatus = 'scheduled';
            
            console.log('Initialized game stats for game:', gameId);
        }
        
        // Game Stats Tracking Functions
        function recordHit(hitType) {
            const currentInningStats = gameStats.innings[gameStats.currentInning - 1];
            const currentBatterStats = gameStats.batters.find(b => b.playerId === gameStats.currentBatter);
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            
            if (currentBatterStats && currentPitcherStats) {
                // Update batter stats
                currentBatterStats.atBats++;
                currentBatterStats.hits++;
                
                // Update season batter stats
                initializePlayerStats(currentBatterStats.playerId);
                seasonPlayerStats.batters[currentBatterStats.playerId].atBats++;
                seasonPlayerStats.batters[currentBatterStats.playerId].hits++;
                
                switch (hitType) {
                    case 'single':
                        currentBatterStats.singles++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].singles++;
                        break;
                    case 'double':
                        currentBatterStats.doubles++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].doubles++;
                        break;
                    case 'triple':
                        currentBatterStats.triples++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].triples++;
                        break;
                    case 'home-run':
                        currentBatterStats.homeRuns++;
                        currentBatterStats.runs++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].homeRuns++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].runs++;
                        // Add run to current inning
                        if (gameStats.isHomeTeam) {
                            currentInningStats.homeRuns++;
                            gameStats.homeScore++;
                        } else {
                            currentInningStats.awayRuns++;
                            gameStats.awayScore++;
                        }
                        break;
                }
                
                // Update pitcher stats
                currentPitcherStats.hitsAllowed++;
                currentPitcherStats.pitchesThrown += Math.floor(Math.random() * 3) + 1; // Mock pitch count
                
                // Update season pitcher stats
                initializePlayerStats(currentPitcherStats.playerId);
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].hitsAllowed++;
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches += Math.floor(Math.random() * 3) + 1;
                
                // Update inning stats
                if (gameStats.isHomeTeam) {
                    currentInningStats.homeHits++;
                } else {
                    currentInningStats.awayHits++;
                }
            }
            
            updateScoreboard();
            updatePitcherStatsDisplay();
            saveSeasonPlayerStats();
            console.log(`Recorded ${hitType} for ${currentBatterStats?.playerName}`);
        }
        
        function recordOut(outType) {
            const currentBatterStats = gameStats.batters.find(b => b.playerId === gameStats.currentBatter);
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            
            if (currentBatterStats && currentPitcherStats) {
                currentBatterStats.atBats++;
                gameStats.currentOuts++;
                
                if (outType === 'strikeout') {
                    currentBatterStats.strikeouts++;
                    currentPitcherStats.strikeouts++;
                }
                
                currentPitcherStats.pitchesThrown += Math.floor(Math.random() * 4) + 2; // Mock pitch count
                
                // Check if inning is complete (3 outs)
                if (gameStats.currentOuts >= 3) {
                    gameStats.currentOuts = 0;
                    gameStats.currentInning++;
                    if (gameStats.currentInning > 9) {
                        gameStats.gameStatus = 'completed';
                    }
                }
            }
            
            updateScoreboard();
            updatePitcherStatsDisplay();
            console.log(`Recorded ${outType} for ${currentBatterStats?.playerName}`);
        }
        
        function recordWalk(walkType) {
            const currentBatterStats = gameStats.batters.find(b => b.playerId === gameStats.currentBatter);
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            
            if (currentBatterStats && currentPitcherStats) {
                currentBatterStats.walks++;
                currentPitcherStats.walks++;
                currentPitcherStats.pitchesThrown += Math.floor(Math.random() * 5) + 3; // Mock pitch count
            }
            
            updateScoreboard();
            updatePitcherStatsDisplay();
            console.log(`Recorded ${walkType} for ${currentBatterStats?.playerName}`);
        }
        
        function addPitch() {
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            if (currentPitcherStats) {
                currentPitcherStats.pitchesThrown++;
                
                // Update season stats
                initializePlayerStats(currentPitcherStats.playerId);
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches++;
            }
            updateScoreboard();
            updatePitcherStatsDisplay();
            saveSeasonPlayerStats();
        }
        
        function addStrike() {
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            if (currentPitcherStats) {
                currentPitcherStats.pitchesThrown++;
                currentPitcherStats.strikeouts++; // Assume strikeout for now
                
                // Update season stats
                initializePlayerStats(currentPitcherStats.playerId);
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches++;
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].strikes++;
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].strikeouts++;
            }
            updateScoreboard();
            updatePitcherStatsDisplay();
            saveSeasonPlayerStats();
        }
        
        function addBall() {
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            if (currentPitcherStats) {
                currentPitcherStats.pitchesThrown++;
                
                // Update season stats
                initializePlayerStats(currentPitcherStats.playerId);
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches++;
                seasonPlayerStats.pitchers[currentPitcherStats.playerId].balls++;
            }
            updateScoreboard();
            updatePitcherStatsDisplay();
            saveSeasonPlayerStats();
        }
        
        function subtractPitch() {
            const currentPitcherStats = gameStats.pitchers.find(p => p.isCurrentPitcher);
            if (currentPitcherStats && currentPitcherStats.pitchesThrown > 0) {
                currentPitcherStats.pitchesThrown--;
                
                // Update season stats
                initializePlayerStats(currentPitcherStats.playerId);
                if (seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches > 0) {
                    seasonPlayerStats.pitchers[currentPitcherStats.playerId].totalPitches--;
                }
            }
            updateScoreboard();
            updatePitcherStatsDisplay();
            saveSeasonPlayerStats();
        }
        
        function recordBatterStat(statType) {
            const currentBatterStats = gameStats.batters.find(b => b.playerId === gameStats.currentBatter);
            if (currentBatterStats) {
                initializePlayerStats(currentBatterStats.playerId);
                
                switch (statType) {
                    case 'stolenBase':
                        currentBatterStats.stolenBases++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].stolenBases++;
                        break;
                    case 'rbi':
                        currentBatterStats.rbi++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].rbi++;
                        break;
                    case 'run':
                        currentBatterStats.runs++;
                        seasonPlayerStats.batters[currentBatterStats.playerId].runs++;
                        break;
                }
                
                saveSeasonPlayerStats();
                console.log(`Recorded ${statType} for ${currentBatterStats.playerName}`);
            }
        }
        
        function startGame() {
            gameStats.gameStatus = 'in-progress';
            updateScoreboard();
            updateGameStatusDisplay();
            console.log('Game started!');
        }
        
        function updateScoreboard() {
            // This will update the scoreboard display
            const scoreboard = document.getElementById('scoreboard');
            if (scoreboard) {
                scoreboard.innerHTML = `
                    <div class="scoreboard-content">
                        <div class="score-display">
                            <div class="team-score">
                                <div class="score-number">${gameStats.homeScore}</div>
                                <div class="team-name">Home</div>
                            </div>
                            <div class="vs">-</div>
                            <div class="team-score">
                                <div class="score-number">${gameStats.awayScore}</div>
                                <div class="team-name">Away</div>
                            </div>
                        </div>
                        <div class="game-info">
                            <span>Inning: ${gameStats.currentInning}</span>
                            <span>Outs: ${gameStats.currentOuts}</span>
                            <span>Status: ${gameStats.gameStatus}</span>
                        </div>
                    </div>
                `;
            }
        }
        
        // Modal Management Functions
        function openGameStats(gameId) {
            initializeGameStats(gameId);
            populatePlayerSelectors();
            updateScoreboard();
            updateGameStatusDisplay();
            document.getElementById('gameStatsModal').style.display = 'flex';
        }
        
        function closeGameStats() {
            document.getElementById('gameStatsModal').style.display = 'none';
        }
        
        function populatePlayerSelectors() {
            const batterSelect = document.getElementById('currentBatterSelect');
            const pitcherSelect = document.getElementById('currentPitcherSelect');
            
            // Clear existing options
            batterSelect.innerHTML = '<option value="">Select Batter</option>';
            pitcherSelect.innerHTML = '<option value="">Select Pitcher</option>';
            
            // Populate batter options
            gameStats.batters.forEach(batter => {
                const option = document.createElement('option');
                option.value = batter.playerId;
                option.textContent = batter.playerName;
                batterSelect.appendChild(option);
            });
            
            // Populate pitcher options
            gameStats.pitchers.forEach(pitcher => {
                const option = document.createElement('option');
                option.value = pitcher.playerId;
                option.textContent = pitcher.playerName;
                pitcherSelect.appendChild(option);
            });
            
            // Set current selections
            if (gameStats.currentBatter) {
                batterSelect.value = gameStats.currentBatter;
            }
            if (gameStats.currentPitcher) {
                pitcherSelect.value = gameStats.currentPitcher;
            }
        }
        
        function setCurrentBatter(playerId) {
            gameStats.currentBatter = playerId;
            console.log('Current batter set to:', playerId);
        }
        
        function setCurrentPitcher(playerId) {
            // Clear previous current pitcher
            gameStats.pitchers.forEach(p => p.isCurrentPitcher = false);
            
            // Set new current pitcher
            const newPitcher = gameStats.pitchers.find(p => p.playerId === playerId);
            if (newPitcher) {
                newPitcher.isCurrentPitcher = true;
                gameStats.currentPitcher = playerId;
                updatePitcherStatsDisplay();
            }
            console.log('Current pitcher set to:', playerId);
        }
        
        function updateGameStatusDisplay() {
            const startSection = document.getElementById('startGameSection');
            const inGameSection = document.getElementById('inGameSection');
            
            if (gameStats.gameStatus === 'scheduled') {
                startSection.style.display = 'block';
                inGameSection.style.display = 'none';
            } else if (gameStats.gameStatus === 'in-progress') {
                startSection.style.display = 'none';
                inGameSection.style.display = 'block';
                updatePitcherStatsDisplay();
            }
        }
        
        function updatePitcherStatsDisplay() {
            const currentPitcher = gameStats.pitchers.find(p => p.isCurrentPitcher);
            const pitcherStatsDiv = document.getElementById('currentPitcherStats');
            
            if (currentPitcher) {
                pitcherStatsDiv.style.display = 'block';
                document.getElementById('currentPitcherName').textContent = `${currentPitcher.playerName} - Pitcher Stats`;
                document.getElementById('pitcherPitches').textContent = currentPitcher.pitchesThrown;
                document.getElementById('pitcherStrikeouts').textContent = currentPitcher.strikeouts;
                document.getElementById('pitcherWalks').textContent = currentPitcher.walks;
                document.getElementById('pitcherHits').textContent = currentPitcher.hitsAllowed;
            } else {
                pitcherStatsDiv.style.display = 'none';
            }
        }
        
        // Data Export/Import Functions
        function exportTeamData() {
            try {
                // Collect all team data
                const teamData = {
                    teamCode: currentTeamCode,
                    players: players,
                    games: games,
                    seasonStats: seasonStats,
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
                
                // Create downloadable file
                const dataStr = JSON.stringify(teamData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                // Create download link
                const link = document.createElement('a');
                link.href = url;
                link.download = `lineup-builder-${currentTeamCode}-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert(`✅ Team data exported successfully!\n\nFile: ${link.download}\n\nTransfer this file to your other device and use "Import Team Data" to sync.`);
                
            } catch (error) {
                console.error('Export failed:', error);
                alert('❌ Export failed. Please try again.');
            }
        }
        
        function importTeamData() {
            // Create file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.style.display = 'none';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        // Validate data structure
                        if (!importedData.teamCode || !importedData.players || !importedData.games) {
                            throw new Error('Invalid data format');
                        }
                        
                        // Confirm import
                        const confirmMessage = `Import data from team "${importedData.teamCode}"?\n\nThis will replace ALL current data on this device:\n- ${importedData.players.length} players\n- ${importedData.games.length} games\n- Season stats\n\nAre you sure?`;
                        
                        if (confirm(confirmMessage)) {
                            // Import the data
                            players = importedData.players || [];
                            games = importedData.games || [];
                            seasonStats = importedData.seasonStats || { playerStats: {}, lastUpdated: null };
                            
                            // Save to localStorage
                            savePlayers();
                            saveGames();
                            saveSeasonStats();
                            
                            // Refresh the UI
                            renderPlayers();
                            renderGames();
                            renderSeasonStats();
                            updateDashboardStats();
                            
                            alert(`✅ Data imported successfully!\n\nTeam: ${importedData.teamCode}\nPlayers: ${players.length}\nGames: ${games.length}\n\nAll data has been synced to this device.`);
                        }
                        
                    } catch (error) {
                        console.error('Import failed:', error);
                        alert('❌ Import failed. Please make sure you selected a valid team data file.');
                    }
                };
                
                reader.readAsText(file);
            };
            
            document.body.appendChild(input);
            input.click();
            document.body.removeChild(input);
        }
        
        // Firebase Cloud Storage Functions
        function getTeamDocRef(teamCode) {
            return db.collection('teams').doc(teamCode);
        }
        
        async function getRemoteData() {
            try {
                const teamRef = getTeamDocRef(currentTeamCode);
                const doc = await teamRef.get();
                if (doc.exists) {
                    return doc.data();
                }
                return null;
            } catch (error) {
                console.error('Error getting remote data:', error);
                return null;
            }
        }
        
        async function saveToFirebase() {
            try {
                const teamRef = getTeamDocRef(currentTeamCode);
                const teamData = {
                    teamCode: currentTeamCode,
                    players: players,
                    games: games,
                    seasonStats: seasonStats,
                    seasonPlayerStats: seasonPlayerStats,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: 'coach' // In a real app, this would be the user ID
                };
                
                await teamRef.set(teamData, { merge: true });
                console.log('Data saved to Firebase successfully');
                updateSyncStatus('connected', 'Synced to cloud');
                return true;
            } catch (error) {
                console.error('Error saving to Firebase:', error);
                updateSyncStatus('error', 'Sync failed - check connection');
                alert('❌ Failed to sync data to cloud. Please check your internet connection.');
                return false;
            }
        }
        
        async function loadFromFirebase() {
            try {
                const teamRef = getTeamDocRef(currentTeamCode);
                const doc = await teamRef.get();
                
                if (doc.exists) {
                    const data = doc.data();
                    players = data.players || [];
                    games = data.games || [];
                    seasonStats = data.seasonStats || { playerStats: {}, lastUpdated: null };
                    seasonPlayerStats = data.seasonPlayerStats || { pitchers: {}, batters: {} };
                    
                    console.log('Data loaded from Firebase successfully');
                    updateSyncStatus('connected', 'Connected to cloud');
                    return true;
                } else {
                    console.log('No team data found in Firebase, starting fresh');
                    return false;
                }
            } catch (error) {
                console.error('Error loading from Firebase:', error);
                updateSyncStatus('error', 'Cloud connection failed');
                alert('❌ Failed to load data from cloud. Using local data instead.');
                return false;
            }
        }
        
        async function setupFirebaseListener() {
            try {
                const teamRef = getTeamDocRef(currentTeamCode);
                
                // Store unsubscribe function globally
                window.firebaseUnsubscribe = teamRef.onSnapshot((doc) => {
                    console.log('Firebase listener triggered, doc exists:', doc.exists);
                    if (doc.exists) {
                        const data = doc.data();
                        const remotePlayers = data.players || [];
                        const remoteGames = data.games || [];
                        const remoteSeasonStats = data.seasonStats || { playerStats: {}, lastUpdated: null };
                        const remoteSeasonPlayerStats = data.seasonPlayerStats || { pitchers: {}, batters: {} };
                        
                        console.log('Remote data received:', { 
                            players: remotePlayers.length, 
                            games: remoteGames.length,
                            seasonPlayerStats: Object.keys(remoteSeasonPlayerStats.pitchers).length + ' pitchers, ' + Object.keys(remoteSeasonPlayerStats.batters).length + ' batters'
                        });
                        
                        // Only update if remote data has actual content AND is newer
                        const localLastUpdated = localStorage.getItem(getStorageKey('lastUpdated'));
                        const remoteLastUpdated = data.lastUpdated;
                        
                        console.log('Firebase listener data check:', {
                            remotePlayers: remotePlayers.length,
                            remoteGames: remoteGames.length,
                            localLastUpdated: localLastUpdated,
                            remoteLastUpdated: remoteLastUpdated,
                            shouldUpdate: remotePlayers.length > 0 && remoteGames.length > 0 && 
                                         (!localLastUpdated || (remoteLastUpdated && remoteLastUpdated > new Date(localLastUpdated)))
                        });
                        
                        if (remotePlayers.length > 0 && remoteGames.length > 0 && 
                            (!localLastUpdated || (remoteLastUpdated && remoteLastUpdated > new Date(localLastUpdated)))) {
                            
                            console.log('Updating from Firebase - remote data is newer and has content');
                            
                            // Smart merge instead of overwrite
                            players = mergePlayers(players, remotePlayers);
                            games = mergeGames(games, remoteGames);
                            seasonStats = mergeSeasonStats(seasonStats, remoteSeasonStats);
                            seasonPlayerStats = mergeSeasonPlayerStats(seasonPlayerStats, remoteSeasonPlayerStats);
                            
                            // Update UI
                            renderPlayers();
                            renderGames();
                            renderSeasonStats();
                            updateDashboardStats();
                            
                            console.log('Data merged from cloud in real-time');
                            
                            // Show notification
                            showSyncNotification('Data updated from cloud!');
                        } else {
                            console.log('Keeping local data - remote is empty or not newer');
                        }
                    } else {
                        console.log('No document found in Firebase for team:', currentTeamCode);
                    }
                });
                
                // Set up periodic sync check every 30 seconds as backup
                window.firebaseInterval = setInterval(async () => {
                    try {
                        const teamRef = getTeamDocRef(currentTeamCode);
                        const doc = await teamRef.get();
                        if (doc.exists) {
                            const data = doc.data();
                            const remoteLastUpdated = data.lastUpdated;
                            const localLastUpdated = localStorage.getItem(getStorageKey('lastUpdated'));
                            
                            // If remote is newer, force a sync
                            if (remoteLastUpdated && (!localLastUpdated || remoteLastUpdated > new Date(localLastUpdated))) {
                                console.log('Periodic sync check: remote data is newer, syncing...');
                                await loadFromFirebase();
                                renderPlayers();
                                renderGames();
                                renderSeasonStats();
                                updateDashboardStats();
                            }
                        }
                    } catch (error) {
                        console.log('Periodic sync check failed:', error);
                    }
                }, 30000); // Check every 30 seconds
                
                console.log('Firebase real-time listener set up');
            } catch (error) {
                console.error('Error setting up Firebase listener:', error);
            }
        }
        
        function showSyncNotification(message) {
            // Create a temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                z-index: 10000;
                font-weight: 500;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 3000);
        }
        
        function updateSyncStatus(status, message) {
            const syncStatusText = document.getElementById('syncStatusText');
            const syncStatus = document.getElementById('syncStatus');
            
            if (syncStatusText && syncStatus) {
                syncStatusText.textContent = message;
                
                // Update colors based on status
                if (status === 'connected') {
                    syncStatus.style.background = '#f0fdf4';
                    syncStatus.style.borderColor = '#10b981';
                } else if (status === 'error') {
                    syncStatus.style.background = '#fef2f2';
                    syncStatus.style.borderColor = '#ef4444';
                } else if (status === 'syncing') {
                    syncStatus.style.background = '#fffbeb';
                    syncStatus.style.borderColor = '#f59e0b';
                }
            }
        }
        
        function showPitcherStats() {
            const content = document.getElementById('playerStatsContent');
            if (!content) return;
            
            let html = '<h4 style="color: #dc2626; margin-bottom: 15px;">🎯 Pitcher Statistics</h4>';
            
            const pitcherStats = seasonPlayerStats.pitchers;
            const pitcherIds = Object.keys(pitcherStats);
            
            if (pitcherIds.length === 0) {
                html += '<p style="color: #6b7280; text-align: center; padding: 20px;">No pitcher statistics recorded yet.</p>';
            } else {
                pitcherIds.forEach(playerId => {
                    const player = players.find(p => p.id === parseInt(playerId));
                    const stats = pitcherStats[playerId];
                    if (player && stats) {
                        html += `
                            <div style="background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                                <h5 style="color: #dc2626; margin: 0 0 10px 0;">${player.name}</h5>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #dc2626;">${stats.totalPitches}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Total Pitches</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #059669;">${stats.strikes}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Strikes</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #f59e0b;">${stats.balls}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Balls</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #ef4444;">${stats.hitsAllowed}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Hits Allowed</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #8b5cf6;">${stats.strikeouts}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Strikeouts</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 8px; border-radius: 4px;">
                                        <div style="font-size: 18px; font-weight: bold; color: #3b82f6;">${stats.walks}</div>
                                        <div style="font-size: 12px; color: #6b7280;">Walks</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });
            }
            
            content.innerHTML = html;
        }
        
        function showBatterStats() {
            const content = document.getElementById('playerStatsContent');
            if (!content) return;
            
            let html = '<h4 style="color: #059669; margin-bottom: 15px;">⚾ Batter Statistics</h4>';
            
            const batterStats = seasonPlayerStats.batters;
            const batterIds = Object.keys(batterStats);
            
            if (batterIds.length === 0) {
                html += '<p style="color: #6b7280; text-align: center; padding: 20px;">No batter statistics recorded yet.</p>';
            } else {
                batterIds.forEach(playerId => {
                    const player = players.find(p => p.id === parseInt(playerId));
                    const stats = batterStats[playerId];
                    if (player && stats) {
                        html += `
                            <div style="background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                                <h5 style="color: #059669; margin: 0 0 10px 0;">${player.name}</h5>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px;">
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #059669;">${stats.atBats}</div>
                                        <div style="font-size: 11px; color: #6b7280;">AB</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #059669;">${stats.hits}</div>
                                        <div style="font-size: 11px; color: #6b7280;">Hits</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #10b981;">${stats.singles}</div>
                                        <div style="font-size: 11px; color: #6b7280;">1B</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #3b82f6;">${stats.doubles}</div>
                                        <div style="font-size: 11px; color: #6b7280;">2B</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #8b5cf6;">${stats.triples}</div>
                                        <div style="font-size: 11px; color: #6b7280;">3B</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #f59e0b;">${stats.homeRuns}</div>
                                        <div style="font-size: 11px; color: #6b7280;">HR</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #ef4444;">${stats.strikeouts}</div>
                                        <div style="font-size: 11px; color: #6b7280;">K</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #06b6d4;">${stats.walks}</div>
                                        <div style="font-size: 11px; color: #6b7280;">BB</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #84cc16;">${stats.stolenBases}</div>
                                        <div style="font-size: 11px; color: #6b7280;">SB</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #f97316;">${stats.rbi}</div>
                                        <div style="font-size: 11px; color: #6b7280;">RBI</div>
                                    </div>
                                    <div style="text-align: center; background: white; padding: 6px; border-radius: 4px;">
                                        <div style="font-size: 16px; font-weight: bold; color: #ec4899;">${stats.runs}</div>
                                        <div style="font-size: 11px; color: #6b7280;">Runs</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });
            }
            
            content.innerHTML = html;
        }
        
        // Force sync function with smart conflict resolution
        async function forceSync() {
            updateSyncStatus('syncing', 'Force syncing...');
            
            try {
                // First, get the latest data from Firebase
                const teamRef = getTeamDocRef(currentTeamCode);
                const doc = await teamRef.get();
                
                if (doc.exists) {
                    const remoteData = doc.data();
                    const remotePlayers = remoteData.players || [];
                    const remoteGames = remoteData.games || [];
                    const remoteSeasonStats = remoteData.seasonStats || { playerStats: {}, lastUpdated: null };
                    const remoteSeasonPlayerStats = remoteData.seasonPlayerStats || { pitchers: {}, batters: {} };
                    const remoteLastUpdated = remoteData.lastUpdated;
                    
                    // Get local last updated time
                    const localLastUpdated = localStorage.getItem(getStorageKey('lastUpdated'));
                    
                    console.log('Sync conflict check:', {
                        remoteLastUpdated: remoteLastUpdated,
                        localLastUpdated: localLastUpdated,
                        localPlayers: players.length,
                        remotePlayers: remotePlayers.length
                    });
                    
                    // Smart merge: combine data instead of overwriting
                    const mergedPlayers = mergePlayers(players, remotePlayers);
                    const mergedGames = mergeGames(games, remoteGames);
                    const mergedSeasonStats = mergeSeasonStats(seasonStats, remoteSeasonStats);
                    const mergedSeasonPlayerStats = mergeSeasonPlayerStats(seasonPlayerStats, remoteSeasonPlayerStats);
                    
                    // Update local data with merged results
                    players = mergedPlayers;
                    games = mergedGames;
                    seasonStats = mergedSeasonStats;
                    seasonPlayerStats = mergedSeasonPlayerStats;
                    
                    // Save merged data back to Firebase
                    await saveToFirebase();
                    
                    // Update UI
                    renderPlayers();
                    renderGames();
                    renderSeasonStats();
                    updateDashboardStats();
                    
                    updateSyncStatus('connected', 'Smart sync complete!');
                    showSyncNotification('Data merged and synced successfully!');
                } else {
                    // No remote data, just save local data
                    await saveToFirebase();
                    updateSyncStatus('connected', 'Data saved to cloud!');
                    showSyncNotification('Data saved to cloud!');
                }
            } catch (error) {
                console.error('Force sync error:', error);
                updateSyncStatus('error', 'Force sync failed');
            }
        }
        
        // Smart merge functions to prevent data loss
        function mergePlayers(localPlayers, remotePlayers) {
            // Safety check: if either array is empty, return the non-empty one
            if (!localPlayers || localPlayers.length === 0) {
                console.log('Local players empty, using remote players');
                return remotePlayers || [];
            }
            if (!remotePlayers || remotePlayers.length === 0) {
                console.log('Remote players empty, using local players');
                return localPlayers || [];
            }
            
            const merged = [...localPlayers];
            const localIds = new Set(localPlayers.map(p => p.id));
            
            // Add any remote players that don't exist locally
            remotePlayers.forEach(remotePlayer => {
                if (!localIds.has(remotePlayer.id)) {
                    merged.push(remotePlayer);
                    console.log('Added remote player:', remotePlayer.name);
                } else {
                    // Update existing player with most recent data
                    const localIndex = merged.findIndex(p => p.id === remotePlayer.id);
                    if (remotePlayer.updatedAt > merged[localIndex].updatedAt) {
                        merged[localIndex] = remotePlayer;
                        console.log('Updated player from remote:', remotePlayer.name);
                    }
                }
            });
            
            return merged;
        }
        
        function mergeGames(localGames, remoteGames) {
            // Safety check: if either array is empty, return the non-empty one
            if (!localGames || localGames.length === 0) {
                console.log('Local games empty, using remote games');
                return remoteGames || [];
            }
            if (!remoteGames || remoteGames.length === 0) {
                console.log('Remote games empty, using local games');
                return localGames || [];
            }
            
            const merged = [...localGames];
            const localIds = new Set(localGames.map(g => g.id));
            
            // Add any remote games that don't exist locally
            remoteGames.forEach(remoteGame => {
                if (!localIds.has(remoteGame.id)) {
                    merged.push(remoteGame);
                    console.log('Added remote game:', remoteGame.opponent);
                } else {
                    // Update existing game with most recent data
                    const localIndex = merged.findIndex(g => g.id === remoteGame.id);
                    if (remoteGame.updatedAt > merged[localIndex].updatedAt) {
                        merged[localIndex] = remoteGame;
                        console.log('Updated game from remote:', remoteGame.opponent);
                    }
                }
            });
            
            return merged;
        }
        
        function mergeSeasonStats(localStats, remoteStats) {
            // Merge player stats, keeping the higher values (more games played)
            const merged = { playerStats: {}, lastUpdated: null };
            
            // Combine all player IDs
            const allPlayerIds = new Set([
                ...Object.keys(localStats.playerStats || {}),
                ...Object.keys(remoteStats.playerStats || {})
            ]);
            
            allPlayerIds.forEach(playerId => {
                const localPlayerStats = localStats.playerStats[playerId] || {};
                const remotePlayerStats = remoteStats.playerStats[playerId] || {};
                
                // Keep the higher values for each stat
                merged.playerStats[playerId] = {
                    gamesPlayed: Math.max(localPlayerStats.gamesPlayed || 0, remotePlayerStats.gamesPlayed || 0),
                    totalInnings: Math.max(localPlayerStats.totalInnings || 0, remotePlayerStats.totalInnings || 0),
                    benchInnings: Math.max(localPlayerStats.benchInnings || 0, remotePlayerStats.benchInnings || 0),
                    infieldInnings: Math.max(localPlayerStats.infieldInnings || 0, remotePlayerStats.infieldInnings || 0),
                    outfieldInnings: Math.max(localPlayerStats.outfieldInnings || 0, remotePlayerStats.outfieldInnings || 0),
                    pitchingInnings: Math.max(localPlayerStats.pitchingInnings || 0, remotePlayerStats.pitchingInnings || 0),
                    catchingInnings: Math.max(localPlayerStats.catchingInnings || 0, remotePlayerStats.catchingInnings || 0)
                };
            });
            
            return merged;
        }
        
        function mergeSeasonPlayerStats(localStats, remoteStats) {
            const merged = { pitchers: {}, batters: {} };
            
            // Merge pitcher stats
            const allPitcherIds = new Set([
                ...Object.keys(localStats.pitchers || {}),
                ...Object.keys(remoteStats.pitchers || {})
            ]);
            
            allPitcherIds.forEach(playerId => {
                const localPitcherStats = localStats.pitchers[playerId] || {};
                const remotePitcherStats = remoteStats.pitchers[playerId] || {};
                
                merged.pitchers[playerId] = {
                    totalPitches: Math.max(localPitcherStats.totalPitches || 0, remotePitcherStats.totalPitches || 0),
                    strikes: Math.max(localPitcherStats.strikes || 0, remotePitcherStats.strikes || 0),
                    balls: Math.max(localPitcherStats.balls || 0, remotePitcherStats.balls || 0),
                    hitsAllowed: Math.max(localPitcherStats.hitsAllowed || 0, remotePitcherStats.hitsAllowed || 0),
                    runsAllowed: Math.max(localPitcherStats.runsAllowed || 0, remotePitcherStats.runsAllowed || 0),
                    strikeouts: Math.max(localPitcherStats.strikeouts || 0, remotePitcherStats.strikeouts || 0),
                    walks: Math.max(localPitcherStats.walks || 0, remotePitcherStats.walks || 0),
                    inningsPitched: Math.max(localPitcherStats.inningsPitched || 0, remotePitcherStats.inningsPitched || 0)
                };
            });
            
            // Merge batter stats
            const allBatterIds = new Set([
                ...Object.keys(localStats.batters || {}),
                ...Object.keys(remoteStats.batters || {})
            ]);
            
            allBatterIds.forEach(playerId => {
                const localBatterStats = localStats.batters[playerId] || {};
                const remoteBatterStats = remoteStats.batters[playerId] || {};
                
                merged.batters[playerId] = {
                    atBats: Math.max(localBatterStats.atBats || 0, remoteBatterStats.atBats || 0),
                    hits: Math.max(localBatterStats.hits || 0, remoteBatterStats.hits || 0),
                    singles: Math.max(localBatterStats.singles || 0, remoteBatterStats.singles || 0),
                    doubles: Math.max(localBatterStats.doubles || 0, remoteBatterStats.doubles || 0),
                    triples: Math.max(localBatterStats.triples || 0, remoteBatterStats.triples || 0),
                    homeRuns: Math.max(localBatterStats.homeRuns || 0, remoteBatterStats.homeRuns || 0),
                    strikeouts: Math.max(localBatterStats.strikeouts || 0, remoteBatterStats.strikeouts || 0),
                    walks: Math.max(localBatterStats.walks || 0, remoteBatterStats.walks || 0),
                    stolenBases: Math.max(localBatterStats.stolenBases || 0, remoteBatterStats.stolenBases || 0),
                    rbi: Math.max(localBatterStats.rbi || 0, remoteBatterStats.rbi || 0),
                    runs: Math.max(localBatterStats.runs || 0, remoteBatterStats.runs || 0)
                };
            });
            
            return merged;
        }
        
        // Emergency data recovery function
        async function recoverData() {
            updateSyncStatus('syncing', 'Attempting data recovery...');
            
            try {
                console.log('🚨 Starting data recovery...');
                
                // Try to recover from localStorage first
                const localPlayers = JSON.parse(localStorage.getItem(getStorageKey('players')) || '[]');
                const localGames = JSON.parse(localStorage.getItem(getStorageKey('games')) || '[]');
                const localSeasonStats = JSON.parse(localStorage.getItem(getStorageKey('seasonStats')) || '{"playerStats": {}, "lastUpdated": null}');
                const localSeasonPlayerStats = JSON.parse(localStorage.getItem(getStorageKey('seasonPlayerStats')) || '{"pitchers": {}, "batters": {}}');
                
                console.log('Local data found:', {
                    players: localPlayers.length,
                    games: localGames.length,
                    seasonStats: Object.keys(localSeasonStats.playerStats).length,
                    seasonPlayerStats: Object.keys(localSeasonPlayerStats.pitchers).length + Object.keys(localSeasonPlayerStats.batters).length
                });
                
                // If we have local data, restore it
                if (localPlayers.length > 0 || localGames.length > 0) {
                    players = localPlayers;
                    games = localGames;
                    seasonStats = localSeasonStats;
                    seasonPlayerStats = localSeasonPlayerStats;
                    
                    // Update UI
                    renderPlayers();
                    renderGames();
                    renderSeasonStats();
                    updateDashboardStats();
                    
                    // Save to Firebase
                    await saveToFirebase();
                    
                    updateSyncStatus('connected', 'Data recovered from local storage!');
                    showSyncNotification('✅ Data recovered from local storage!');
                    return;
                }
                
                // Try to recover from Firebase
                const teamRef = getTeamDocRef(currentTeamCode);
                const doc = await teamRef.get();
                
                if (doc.exists) {
                    const data = doc.data();
                    players = data.players || [];
                    games = data.games || [];
                    seasonStats = data.seasonStats || { playerStats: {}, lastUpdated: null };
                    seasonPlayerStats = data.seasonPlayerStats || { pitchers: {}, batters: {} };
                    
                    // Update UI
                    renderPlayers();
                    renderGames();
                    renderSeasonStats();
                    updateDashboardStats();
                    
                    updateSyncStatus('connected', 'Data recovered from cloud!');
                    showSyncNotification('✅ Data recovered from cloud!');
                    return;
                }
                
                // If no data found anywhere
                updateSyncStatus('error', 'No data found to recover');
                showSyncNotification('❌ No data found in local storage or cloud');
                
            } catch (error) {
                console.error('Data recovery failed:', error);
                updateSyncStatus('error', 'Data recovery failed');
                showSyncNotification('❌ Data recovery failed');
            }
        }
        
        // Safe Mode function to disable Firebase and use only local storage
        function enableSafeMode() {
            if (confirm('Enable Safe Mode? This will disable Firebase sync and use only local storage to prevent data corruption. You can still export/import data manually.')) {
                safeMode = true;
                localStorage.setItem('lineupBuilder_safeMode', 'true');
                
                // Completely disable Firebase
                if (window.firebaseUnsubscribe) {
                    window.firebaseUnsubscribe();
                    console.log('Firebase listener unsubscribed');
                }
                
                if (window.firebaseInterval) {
                    clearInterval(window.firebaseInterval);
                    console.log('Firebase interval cleared');
                }
                
                // Reload data from localStorage only
                loadPlayers();
                loadGames();
                loadSeasonStats();
                loadSeasonPlayerStats();
                
                // Update UI
                renderPlayers();
                renderGames();
                renderSeasonStats();
                updateDashboardStats();
                
                updateSyncStatus('connected', 'Safe Mode: Local storage only');
                showSyncNotification('🛡️ Safe Mode enabled - Firebase sync disabled');
                
                console.log('Safe Mode enabled - Firebase sync disabled');
            }
        }
        
        // Reset to default function for emergency recovery
        function resetToDefault() {
            if (confirm('Reset to Default? This will clear all data and start fresh. This cannot be undone!')) {
                // Clear all localStorage
                Object.keys(localStorage).forEach(key => {
                    if (key.includes('lineupBuilder')) {
                        localStorage.removeItem(key);
                    }
                });
                
                // Reset global variables
                players = [];
                games = [];
                seasonStats = { playerStats: {}, lastUpdated: null };
                seasonPlayerStats = { pitchers: {}, batters: {} };
                safeMode = false;
                
                // Reload the page
                location.reload();
            }
        }
        
        // Restore players from localStorage
        function restorePlayers() {
            try {
                const localPlayers = localStorage.getItem(getStorageKey('players'));
                if (localPlayers) {
                    const restoredPlayers = JSON.parse(localPlayers);
                    players = restoredPlayers;
                    renderPlayers();
                    console.log('Players restored from localStorage:', players.length);
                    showSyncNotification('✅ Players restored from local storage!');
                } else {
                    alert('No player data found in local storage');
                }
            } catch (error) {
                console.error('Error restoring players:', error);
                alert('Error restoring players: ' + error.message);
            }
        }
        
        // Team management functions
        async function initializeTeam() {
            // Check for Safe Mode first
            const safeModeEnabled = localStorage.getItem('lineupBuilder_safeMode') === 'true';
            if (safeModeEnabled) {
                safeMode = true;
                console.log('Safe Mode detected - skipping Firebase sync');
            }
            
            // Check if we have a team code in localStorage
            const savedTeamCode = localStorage.getItem('lineupBuilder_teamCode');
            
            if (savedTeamCode) {
                currentTeamCode = savedTeamCode;
                console.log('Using existing team code:', currentTeamCode);
            } else {
                // Prompt for team code
                const teamCode = prompt('Enter your team code (e.g., "kimner", "thunderbolts", etc.) or create a new one:');
                if (teamCode && teamCode.trim()) {
                    currentTeamCode = teamCode.trim().toLowerCase().replace(/\s+/g, '');
                    localStorage.setItem('lineupBuilder_teamCode', currentTeamCode);
                    console.log('Created new team code:', currentTeamCode);
                } else {
                    currentTeamCode = 'default';
                    localStorage.setItem('lineupBuilder_teamCode', currentTeamCode);
                    console.log('Using default team code');
                }
            }
            
            // Load from localStorage first to show data immediately
            loadPlayers();
            loadGames();
            loadSeasonStats();
            loadSeasonPlayerStats();
            
            // Update UI with local data first
            renderPlayers();
            renderGames();
            renderSeasonStats();
            updateDashboardStats();
            
            console.log('Local data loaded:', {
                players: players.length,
                games: games.length,
                seasonStats: Object.keys(seasonStats.playerStats).length
            });
            console.log('DEBUG: App version with catcher rotation debugging loaded');
            
            if (safeMode) {
                // Safe Mode: Skip Firebase entirely
                updateSyncStatus('connected', 'Safe Mode: Local storage only');
                console.log('Safe Mode active - Firebase sync disabled');
                
                // Completely disable Firebase listeners
                if (window.firebaseUnsubscribe) {
                    window.firebaseUnsubscribe();
                    console.log('Firebase listener unsubscribed');
                }
                
                // Clear any Firebase intervals
                if (window.firebaseInterval) {
                    clearInterval(window.firebaseInterval);
                    console.log('Firebase interval cleared');
                }
                
                return; // Exit early, don't set up Firebase
            } else {
                // Wait a moment to ensure UI is stable
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Then try to load from Firebase in background
                const firebaseLoaded = await loadFromFirebase();
                
                if (firebaseLoaded) {
                    // Only update UI if Firebase has more recent data
                    const remoteData = await getRemoteData();
                    if (remoteData && remoteData.lastUpdated) {
                        const localLastUpdated = localStorage.getItem(getStorageKey('lastUpdated'));
                        if (!localLastUpdated || remoteData.lastUpdated > new Date(localLastUpdated)) {
                            console.log('Firebase has newer data, updating UI');
                            renderPlayers();
                            renderGames();
                            renderSeasonStats();
                            updateDashboardStats();
                        } else {
                            console.log('Local data is newer, keeping local data');
                        }
                    }
                }
                
                // Set up real-time listener for team collaboration (delayed to prevent interference)
                setTimeout(() => {
                    setupFirebaseListener();
                }, 2000);
                
                // Update sync status to show connection
                updateSyncStatus('connected', 'Connected to cloud');
            }
            
            // Update the page title to show team
            updatePageTitle();
        }
        
        function updatePageTitle() {
            if (currentTeamCode && currentTeamCode !== 'default') {
                document.title = `Lineup Builder - ${currentTeamCode.charAt(0).toUpperCase() + currentTeamCode.slice(1)}`;
                // Also update the header if we want
                const header = document.querySelector('h1');
                if (header) {
                    header.innerHTML = `⚾ Lineup Builder - ${currentTeamCode.charAt(0).toUpperCase() + currentTeamCode.slice(1)}`;
                }
            }
        }
        
        function getStorageKey(baseKey) {
            return `lineupBuilder_${currentTeamCode}_${baseKey}`;
        }
        
        // Season stats management
        function loadSeasonStats() {
            const saved = localStorage.getItem(getStorageKey('seasonStats'));
            if (saved) {
                seasonStats = JSON.parse(saved);
            }
        }
        
        async function saveSeasonStats() {
            localStorage.setItem(getStorageKey('seasonStats'), JSON.stringify(seasonStats));
            if (!safeMode) {
                await saveToFirebase(); // Also save to cloud
            }
        }
        
        function updateSeasonStats(gameLineup) {
            console.log('updateSeasonStats called with:', gameLineup);
            
            // Check if gameLineup is valid
            if (!gameLineup || !Array.isArray(gameLineup)) {
                console.log('Invalid gameLineup, skipping season stats update');
                return;
            }
            
            // Update cumulative stats based on this game's lineup
            gameLineup.forEach(inning => {
                if (!inning) {
                    console.log('Invalid inning data, skipping:', inning);
                    return;
                }
                
                // Handle the actual data structure: {P: 'playerName', C: 'playerName', ...}
                Object.entries(inning).forEach(([position, playerName]) => {
                    if (position === 'bench') return; // Skip bench data
                    
                    // Find player by name
                    const player = players.find(p => p.name === playerName);
                    if (!player) {
                        console.log('Player not found:', playerName);
                        return;
                    }
                    
                    const playerId = player.id;
                    if (!seasonStats.playerStats[playerId]) {
                        seasonStats.playerStats[playerId] = {
                            totalInnings: 0,
                            benchInnings: 0,
                            infieldInnings: 0,
                            outfieldInnings: 0,
                            pitchingInnings: 0,
                            catchingInnings: 0,
                            gamesPlayed: 0
                        };
                    }
                    
                    const stats = seasonStats.playerStats[playerId];
                    stats.totalInnings++;
                    
                    // Categorize position
                    if (position === 'P') {
                        stats.pitchingInnings++;
                        stats.infieldInnings++; // P counts as infield
                    } else if (position === 'C') {
                        stats.catchingInnings++;
                        stats.infieldInnings++; // C counts as infield
                    } else if (['1B', '2B', 'SS', '3B'].includes(position)) {
                        stats.infieldInnings++;
                    } else if (['LF', 'CF', 'RF'].includes(position)) {
                        stats.outfieldInnings++;
                    }
                });
            });
            
            // Count bench time for players not in this game's lineup
            const playersInGame = new Set();
            gameLineup.forEach(inning => {
                Object.entries(inning).forEach(([position, playerName]) => {
                    if (position === 'bench') return; // Skip bench data
                    const player = players.find(p => p.name === playerName);
                    if (player) {
                        playersInGame.add(player.id);
                    }
                });
            });
            
            players.forEach(player => {
                if (!seasonStats.playerStats[player.id]) {
                    seasonStats.playerStats[player.id] = {
                        totalInnings: 0,
                        benchInnings: 0,
                        infieldInnings: 0,
                        outfieldInnings: 0,
                        pitchingInnings: 0,
                        catchingInnings: 0,
                        gamesPlayed: 0
                    };
                }
                
                if (!playersInGame.has(player.id)) {
                    // Player was benched for this entire game
                    seasonStats.playerStats[player.id].benchInnings += gameLineup.length;
                } else {
                    // Player participated in this game (increment gamesPlayed by 1 per game)
                    seasonStats.playerStats[player.id].gamesPlayed++;
                }
            });
            
            seasonStats.lastUpdated = new Date().toISOString();
            saveSeasonStats();
        }
        
        function getPlayerPriority(player, position, cumulativeTargetInfield, cumulativeTargetOutfield) {
            // Calculate priority based on how far behind this player is in cumulative stats
            const stats = seasonStats.playerStats[player.id] || {
                totalInnings: 0,
                benchInnings: 0,
                infieldInnings: 0,
                outfieldInnings: 0,
                pitchingInnings: 0,
                catchingInnings: 0,
                gamesPlayed: 0
            };
            
            let priority = 0;
            
            // Position-specific priority
            if (position === 'P') {
                // Prioritize players with fewer pitching innings
                priority += (cumulativeTargetInfield - stats.pitchingInnings) * 10;
            } else if (position === 'C') {
                // Prioritize players with fewer catching innings
                priority += (cumulativeTargetInfield - stats.catchingInnings) * 10;
            } else if (['1B', '2B', 'SS', '3B'].includes(position)) {
                // Prioritize players with fewer infield innings
                priority += (cumulativeTargetInfield - stats.infieldInnings) * 5;
            } else if (['LF', 'CF', 'RF'].includes(position)) {
                // Prioritize players with fewer outfield innings
                priority += (cumulativeTargetOutfield - stats.outfieldInnings) * 5;
            }
            
            // Overall playing time priority
            priority += (cumulativeTargetInfield + cumulativeTargetOutfield - stats.totalInnings) * 2;
            
            // Bench time priority (players who have been benched more should get priority)
            priority += stats.benchInnings * 3;
            
            return priority;
        }
        
        // Debug function to check lineup generation readiness
        function debugLineupGeneration() {
            console.log('=== LINEUP GENERATION DEBUG ===');
            console.log('Total players in roster:', players.length);
            console.log('Players:', players.map(p => ({ id: p.id, name: p.name, positions: p.availablePositions })));
            console.log('Total games:', games.length);
            console.log('Games:', games.map(g => ({ id: g.id, opponent: g.opponent, availablePlayers: g.availablePlayers })));
            console.log('Season stats:', seasonStats);
            
            if (players.length < 8) {
                console.log('❌ ISSUE: Need at least 8 players in roster');
                return false;
            }
            
            const pitchers = players.filter(p => p.availablePositions.includes('P'));
            if (pitchers.length === 0) {
                console.log('❌ ISSUE: No pitchers found. Players need "P" in availablePositions');
                return false;
            }
            
            if (games.length === 0) {
                console.log('❌ ISSUE: No games found. Add a game first.');
                return false;
            }
            
            const lastGame = games[games.length - 1];
            const availablePlayers = players.filter(p => lastGame.availablePlayers.includes(p.id));
            console.log('Last game available players:', availablePlayers.length);
            
            if (availablePlayers.length < 8) {
                console.log('❌ ISSUE: Not enough players available for last game');
                console.log('Available players:', availablePlayers.map(p => p.name));
                return false;
            }
            
            console.log('✅ All checks passed! Lineup generation should work.');
            return true;
        }
        
        // Test function to verify button is working
        function testGenerateButton() {
            console.log('=== TESTING GENERATE BUTTON ===');
            const button = document.getElementById('generateLineupBtn');
            if (!button) {
                console.log('❌ Button not found in DOM');
                return false;
            }
            console.log('✅ Button found:', button);
            console.log('Button onclick:', button.onclick);
            console.log('Button style:', button.style.cssText);
            console.log('Button disabled:', button.disabled);
            console.log('Current game detail:', currentGameDetail);
            return true;
        }
        
        // Render season statistics
        function renderSeasonStats() {
            const content = document.getElementById('seasonStatsContent');
            if (!content) return;
            
            // Load current season stats
            loadSeasonStats();
            
            // Check if we have any stats
            const playerStats = seasonStats.playerStats || {};
            const playerIds = Object.keys(playerStats);
            
            if (playerIds.length === 0) {
                content.innerHTML = '<p style="color: #6b7280;">No games played yet. Generate lineups to see season statistics.</p>';
                return;
            }
            
            // Calculate averages
            const stats = Object.values(playerStats);
            const avgInnings = stats.reduce((sum, p) => sum + (p.totalInnings || 0), 0) / stats.length;
            const avgBench = stats.reduce((sum, p) => sum + (p.benchInnings || 0), 0) / stats.length;
            const avgInfield = stats.reduce((sum, p) => sum + (p.infieldInnings || 0), 0) / stats.length;
            const avgOutfield = stats.reduce((sum, p) => sum + (p.outfieldInnings || 0), 0) / stats.length;
            const avgPitching = stats.reduce((sum, p) => sum + (p.pitchingInnings || 0), 0) / stats.length;
            const avgCatching = stats.reduce((sum, p) => sum + (p.catchingInnings || 0), 0) / stats.length;
            
            let html = `
                <div style="margin-bottom: 20px;">
                    <h3>Season Averages</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px;">
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Total Innings</strong><br>${avgInnings.toFixed(1)}
                        </div>
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Bench Time</strong><br>${avgBench.toFixed(1)}
                        </div>
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Infield Time</strong><br>${avgInfield.toFixed(1)}
                        </div>
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Outfield Time</strong><br>${avgOutfield.toFixed(1)}
                        </div>
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Pitching Time</strong><br>${avgPitching.toFixed(1)}
                        </div>
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 5px; text-align: center;">
                            <strong>Catching Time</strong><br>${avgCatching.toFixed(1)}
                        </div>
                    </div>
                </div>
                
                <h3>Player Statistics</h3>
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                        <thead>
                            <tr style="background: #f3f4f6;">
                                <th style="padding: 10px; text-align: left; border: 1px solid #d1d5db;">Player</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Games</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Total Innings</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Bench Time</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Infield</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Outfield</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Pitching</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">Catching</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort players by name for consistent display
            const sortedPlayers = playerIds
                .map(id => ({ id: parseInt(id), stats: playerStats[id], player: players.find(p => p.id === parseInt(id)) }))
                .filter(item => item.player)
                .sort((a, b) => a.player.name.localeCompare(b.player.name));
            
            sortedPlayers.forEach(({ player, stats }) => {
                const totalInnings = stats.totalInnings || 0;
                const benchInnings = stats.benchInnings || 0;
                const infieldInnings = stats.infieldInnings || 0;
                const outfieldInnings = stats.outfieldInnings || 0;
                const pitchingInnings = stats.pitchingInnings || 0;
                const catchingInnings = stats.catchingInnings || 0;
                const gamesPlayed = stats.gamesPlayed || 0;
                
                // Check for imbalances (more than +/- 1.5 from average)
                // Only flag as imbalanced if the player participated in games but got uneven playing time
                // Don't flag players who missed games entirely (that's expected)
                const totalImbalanced = gamesPlayed > 0 && Math.abs(totalInnings - avgInnings) > 1.5;
                const benchImbalanced = gamesPlayed > 0 && Math.abs(benchInnings - avgBench) > 1.5;
                const infieldImbalanced = gamesPlayed > 0 && Math.abs(infieldInnings - avgInfield) > 1.5;
                const outfieldImbalanced = gamesPlayed > 0 && Math.abs(outfieldInnings - avgOutfield) > 1.5;
                
                // Check if player can pitch or catch
                const canPitch = player.availablePositions.includes('P');
                const canCatch = player.availablePositions.includes('C');
                
                // Only check pitching/catching imbalances if player can play those positions and participated in games
                const pitchingImbalanced = canPitch && gamesPlayed > 0 && Math.abs(pitchingInnings - avgPitching) > 1.5;
                const catchingImbalanced = canCatch && gamesPlayed > 0 && Math.abs(catchingInnings - avgCatching) > 1.5;
                
                const getCellStyle = (isImbalanced) => isImbalanced ? 'background: #fef2f2; color: #dc2626; font-weight: bold;' : '';
                
                // Format pitching and catching display
                const pitchingDisplay = canPitch ? pitchingInnings : 'N/A';
                const catchingDisplay = canCatch ? catchingInnings : 'N/A';
                
                html += `
                    <tr>
                        <td style="padding: 10px; border: 1px solid #d1d5db; font-weight: bold;">${player.name}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db;">${gamesPlayed}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(totalImbalanced)}">${totalInnings}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(benchImbalanced)}">${benchInnings}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(infieldImbalanced)}">${infieldInnings}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(outfieldImbalanced)}">${outfieldInnings}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(pitchingImbalanced)}">${pitchingDisplay}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #d1d5db; ${getCellStyle(catchingImbalanced)}">${catchingDisplay}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px;">
                    <h4 style="color: #dc2626; margin: 0 0 10px 0;">⚠️ Imbalance Alert</h4>
                    <p style="margin: 0; color: #991b1b; font-size: 0.9rem;">
                        <strong>Red numbers</strong> indicate values that are more than ±1.5 from the team average.                                                                                                       
                        These players may need priority in future lineup generation to restore balance.
                    </p>
                </div>
            `;
            
            content.innerHTML = html;
        }
        
        // Fast QA Test function
        async function runFastQATest() {
            console.log('=== FAST QA TEST STARTING ===');
            
            // Test 1: Check basic setup
            console.log('Test 1: Basic Setup Check');
            if (players.length < 8) {
                alert('❌ QA Test Failed: Need at least 8 players. Currently have ' + players.length);
                return;
            }
            console.log('✅ Players: ' + players.length);
            
            const pitchers = players.filter(p => p.availablePositions.includes('P'));
            if (pitchers.length === 0) {
                alert('❌ QA Test Failed: Need at least 1 pitcher');
                return;
            }
            console.log('✅ Pitchers: ' + pitchers.length);
            
            // Test 2: Check if we have games
            if (games.length === 0) {
                alert('❌ QA Test Failed: No games found. Add a game first.');
                return;
            }
            console.log('✅ Games: ' + games.length);
            
            // Test 3: Generate a test lineup
            console.log('Test 3: Lineup Generation');
            const testGame = games[0];
            if (!testGame || !testGame.availablePlayers || testGame.availablePlayers.length < 8) {
                alert('❌ QA Test Failed: First game needs 8+ available players');
                return;
            }
            
            // Temporarily set currentGameDetail for testing
            const originalGameDetail = currentGameDetail;
            currentGameDetail = testGame;
            
            try {
                // Generate lineup
                await generateLineupForGame(testGame.id);
                console.log('✅ Lineup generated successfully');
                
                // Test 4: Check season stats
                console.log('Test 4: Season Stats Check');
                loadSeasonStats();
                const playerStats = seasonStats.playerStats || {};
                const playerCount = Object.keys(playerStats).length;
                
                if (playerCount === 0) {
                    console.log('⚠️ No season stats found - this might be expected for first game');
                } else {
                    console.log('✅ Season stats found for ' + playerCount + ' players');
                }
                
                // Test 5: Check lineup display
                console.log('Test 5: Lineup Display Check');
                const lineupDisplay = document.getElementById('lineup-display');
                if (lineupDisplay && lineupDisplay.innerHTML.length > 100) {
                    console.log('✅ Lineup display updated');
                } else {
                    console.log('⚠️ Lineup display might not be showing');
                }
                
                // Test 6: Test view saved lineup
                console.log('Test 6: View Saved Lineup');
                if (testGame.generatedLineup) {
                    viewSavedLineup(testGame.id);
                    console.log('✅ View saved lineup works');
                } else {
                    console.log('⚠️ No saved lineup to test');
                }
                
                // Restore original game detail
                currentGameDetail = originalGameDetail;
                
                // Show results
                alert('✅ Fast QA Test PASSED!\n\n' +
                      '• Players: ' + players.length + '\n' +
                      '• Pitchers: ' + pitchers.length + '\n' +
                      '• Games: ' + games.length + '\n' +
                      '• Season Stats: ' + playerCount + ' players\n' +
                      '• Lineup Generation: Working\n' +
                      '• View Saved Lineup: Working\n\n' +
                      'Check the Season Stats tab to see cumulative data!');
                
                // Refresh season stats display
                renderSeasonStats();
                
            } catch (error) {
                console.error('❌ QA Test Error:', error);
                alert('❌ QA Test FAILED: ' + error.message);
                currentGameDetail = originalGameDetail;
            }
            
            console.log('=== FAST QA TEST COMPLETE ===');
        }
        
        // Clear season stats function
        function clearSeasonStats() {
            if (confirm('Are you sure you want to clear all season statistics? This will reset all cumulative player data.')) {                                                                                         
                seasonStats = {
                    playerStats: {},
                    lastUpdated: null
                };
                saveSeasonStats();
                renderSeasonStats();
                alert('Season statistics cleared!');
            }
        }
        
        // Rebuild season stats from all existing saved lineups
        function rebuildSeasonStats() {
            console.log('Rebuilding season stats from existing lineups...');
            
            // Clear existing stats
            seasonStats = {
                playerStats: {},
                lastUpdated: null
            };
            
            // Process each game that has a saved lineup
            let gamesProcessed = 0;
            games.forEach(game => {
                if (game.generatedLineup && game.generatedLineup.innings && game.generatedLineup.innings.length > 0) {
                    console.log(`Processing lineup for game vs ${game.opponent}`);
                    updateSeasonStats(game.generatedLineup.innings);
                    gamesProcessed++;
                }
            });
            
            console.log(`Processed ${gamesProcessed} games with saved lineups`);
            saveSeasonStats();
            renderSeasonStats();
            
            if (gamesProcessed > 0) {
                alert(`✅ Rebuilt season stats from ${gamesProcessed} saved lineups!`);
            } else {
                alert('No saved lineups found to rebuild stats from.');
            }
        }
        
        // Simple test function to verify button functionality
        function testButtonClick() {
            console.log('Testing button click...');
            const button = document.getElementById('generateLineupBtn');
            if (button) {
                console.log('Button found, simulating click...');
                button.click();
            } else {
                console.log('Button not found!');
            }
        }
        
        function logout() {
            if (confirm('Are you sure you want to logout? This will clear your current team data from this browser and you will need to enter your team code again.')) {
                localStorage.removeItem('lineupBuilder_teamCode');
                location.reload();
            }
        }
        
        
        // Team management
        let currentTeamCode = null;
        
        // Player data storage with localStorage persistence
        let players = [];
        let nextPlayerId = 14;
        
        // Game data storage with localStorage persistence
        let games = [];
        let nextGameId = 1;
        
        // Lineup data
        let lineup = [];
        let manualPitcherSelections = {}; // Store manual pitcher selections
        
        // Season-long tracking for cumulative balance
        let seasonStats = {
            playerStats: {}, // playerId -> { totalInnings, benchInnings, infieldInnings, outfieldInnings, pitchingInnings, catchingInnings, gamesPlayed }
            lastUpdated: null
        };
        
        // Default player data
        const defaultPlayers = [
            {
                id: 1,
                name: "Quincy",
                availablePositions: ["P", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 2,
                name: "Mason",
                availablePositions: ["P", "C", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 3,
                name: "George",
                availablePositions: ["C", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 4,
                name: "Gerry",
                availablePositions: ["P", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 5,
                name: "Clifford",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 6,
                name: "Caden",
                availablePositions: ["P", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 7,
                name: "Emerson",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 8,
                name: "Gideon",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 9,
                name: "Nolan",
                availablePositions: ["P", "1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 10,
                name: "Clark",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 11,
                name: "Aazim",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 12,
                name: "Chester",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            },
            {
                id: 13,
                name: "Cameron",
                availablePositions: ["1B", "2B", "SS", "3B", "LF", "CF", "RF"]
            }
        ];
        
        // Load players from localStorage or start with empty roster
        function loadPlayers() {
            const savedPlayers = localStorage.getItem(getStorageKey('players'));
            if (savedPlayers) {
                players = JSON.parse(savedPlayers);
                // Update nextPlayerId to be higher than any existing player ID
                nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
            } else {
                // Start with empty roster for new teams
                players = [];
                nextPlayerId = 1;
            }
        }
        
        // Save players to localStorage
        async function savePlayers() {
            localStorage.setItem(getStorageKey('players'), JSON.stringify(players));
            if (!safeMode) {
                try {
                    await saveToFirebase(); // Also save to cloud
                } catch (error) {
                    console.error('Firebase sync failed:', error);
                    // Don't show error to user, just log it
                    // Data is still saved locally
                }
            }
        }
        
        let editingPlayerId = null;
        
        function showSection(sectionName) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.add('hidden');
            });
            
            // Remove active class from all nav buttons
            document.querySelectorAll('.nav button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(sectionName).classList.remove('hidden');
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Refresh player list when showing players section
            if (sectionName === 'players') {
                renderPlayers();
            }
            
            // Refresh game player checkboxes when showing games section
            if (sectionName === 'games') {
                renderGamePlayerCheckboxes();
            }
            
            // Refresh season stats when showing season stats section
            if (sectionName === 'seasonStats') {
                renderSeasonStats();
            }
        }
        
        function renderPlayers() {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';
            
            players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                playerCard.innerHTML = `
                    <div class="player-name">${player.name}</div>
                    <div class="position-badges">
                        ${player.availablePositions.includes('P') ? '<span class="badge badge-pitcher">Pitcher</span>' : ''}
                        ${player.availablePositions.includes('C') ? '<span class="badge badge-catcher">Catcher</span>' : ''}
                    </div>
                    <p><strong>Available Positions:</strong> ${player.availablePositions.join(', ')}</p>
                    <div class="player-actions">
                        <button class="btn btn-small btn-secondary" onclick="editPlayer(${player.id})">Edit</button>
                    </div>
                `;
                playerList.appendChild(playerCard);
            });
            
            // Update stats
            updateStats();
        }
        
        function updateStats() {
            const totalPlayers = players.length;
            const pitchers = players.filter(p => p.availablePositions.includes('P')).length;
            const catchers = players.filter(p => p.availablePositions.includes('C')).length;
            
            document.querySelector('.stat-number').textContent = totalPlayers;
            document.querySelectorAll('.stat-number')[1].textContent = pitchers;
            document.querySelectorAll('.stat-number')[2].textContent = catchers;
        }
        
        function addPlayer() {
            const name = document.getElementById('playerName').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }
            
            
            const availablePositions = [];
            const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
            positions.forEach(pos => {
                if (document.getElementById(`pos-${pos}`).checked) {
                    availablePositions.push(pos);
                }
            });
            
            if (availablePositions.length === 0) {
                alert('Player must be available for at least one position');
                return;
            }
            
            if (editingPlayerId) {
                // Editing existing player
                console.log('Updating player with ID:', editingPlayerId);
                const playerIndex = players.findIndex(p => p.id === editingPlayerId);
                console.log('Found player at index:', playerIndex);
                
                if (playerIndex !== -1) {
                    const oldPlayer = players[playerIndex];
                    console.log('Old player:', oldPlayer);
                    
                    players[playerIndex] = {
                        id: editingPlayerId,
                        name: name,
                        availablePositions: availablePositions,
                        createdAt: oldPlayer.createdAt, // Preserve creation date
                        updatedAt: new Date().toISOString() // Add update timestamp
                    };
                    
                    console.log('New player:', players[playerIndex]);
                } else {
                    console.error('Player not found for editing!');
                    alert('Error: Player not found for editing');
                    return;
                }
                editingPlayerId = null;
            } else {
                // Adding new player
                const newPlayer = {
                    id: nextPlayerId++,
                    name: name,
                    availablePositions: availablePositions
                };
                players.push(newPlayer);
            }
            
            clearForm();
            savePlayers(); // Save changes to localStorage
            renderPlayers();
        }
        
        function clearForm() {
            document.getElementById('playerName').value = '';
            
            const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
            positions.forEach(pos => {
                document.getElementById(`pos-${pos}`).checked = true;
            });
            
            // Reset button text and editing state
            editingPlayerId = null;
            const button = document.getElementById('addEditButton');
            button.textContent = 'Add Player';
            button.onclick = function() { addPlayer(); }; // Ensure onclick is set
        }
        
        function editPlayer(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            console.log('Editing player:', player.name, 'ID:', playerId);
            
            // Set editing state
            editingPlayerId = playerId;
            
            // Fill form with player data
            document.getElementById('playerName').value = player.name;
            
            const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
            positions.forEach(pos => {
                document.getElementById(`pos-${pos}`).checked = player.availablePositions.includes(pos);
            });
            
            // Change button text and onclick
            const button = document.getElementById('addEditButton');
            button.textContent = 'Update Player';
            button.onclick = function() { addPlayer(); }; // Ensure it calls addPlayer
            
            // Scroll to form
            document.querySelector('.player-form').scrollIntoView({ behavior: 'smooth' });
        }
        
        async function deletePlayer(playerId) {
            const player = players.find(p => p.id === playerId);
            if (!player) return;
            
            if (confirm(`Are you sure you want to delete ${player.name}? This will remove them from all games and lineups.`)) {
                // Remove player from players array
                players = players.filter(p => p.id !== playerId);
                
                // Remove player from all games
                games.forEach(game => {
                    game.availablePlayers = game.availablePlayers.filter(id => id !== playerId);
                });
                
                // Save changes
                await savePlayers();
                await saveGames();
                
                // Update UI
                renderPlayers();
                renderGames();
                updateDashboardStats();
                
                console.log(`Player ${player.name} deleted successfully`);
            }
        }
        
        
        function renderPlayers() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return;
            
            playerList.innerHTML = '';
            
            players.forEach(player => {
                const playerCard = document.createElement('div');
                playerCard.className = 'player-card';
                
                const positions = player.availablePositions.join(', ');
                
                playerCard.innerHTML = `
                    <div class="player-info">
                        <h4>${player.name}</h4>
                        <p><strong>Positions:</strong> ${positions}</p>
                    </div>
                    <div class="player-actions">
                        <button class="btn btn-sm btn-secondary" onclick="editPlayer(${player.id})">Edit</button>
                        <button class="btn btn-sm btn-danger" onclick="deletePlayer(${player.id})" style="background: #dc2626; color: white; margin-left: 8px;">🗑️ Delete</button>
                    </div>
                `;
                
                playerList.appendChild(playerCard);
            });
            
            // Update dashboard stats whenever players are rendered
            updateDashboardStats();
        }
        
        function generateLineup() {
            if (players.length < 8) {
                alert('You need at least 8 players to generate a lineup');
                return;
            }
            
            const pitchers = players.filter(p => p.availablePositions.includes('P'));
            if (pitchers.length === 0) {
                alert('You need at least one pitcher to generate a lineup');
                return;
            }
            
            // Simple lineup generation algorithm
            const lineup = generateSmartLineup(players, 'default');
            
            // If we're in game detail view, update the lineup display there
            if (currentGameDetail) {
                const lineupDisplay = document.getElementById('lineup-display');
                if (lineupDisplay) {
                    lineupDisplay.innerHTML = lineup;
                }
            }
            
            return lineup;
        }
        
        function generateSmartLineup(gamePlayers, gameId) {
            console.log('=== generateSmartLineup START ===');
            const innings = 6;
            
            // Initialize the global lineup array
            lineup = [];
            console.log('Initialized lineup array:', lineup);
            
            // Get the opponent name from the current game or use a default
            const game = games.find(g => g.id === gameId);
            const opponentName = game ? game.opponent : (currentGameDetail ? currentGameDetail.opponent : 'Opponent');
            console.log('Opponent name:', opponentName);
            let lineupHTML = `<h3>Kimner vs ${opponentName} - ${innings} Innings</h3>`;
            
            // Use the provided gamePlayers instead of global players array
            const shuffledPlayers = [...gamePlayers].sort(() => Math.random() - 0.5);
            const numPlayers = shuffledPlayers.length;
            
            // Determine positions based on number of players
            let positions, infieldPositions, outfieldPositions, playersPerInning;
            
            if (numPlayers === 8) {
                // 8 players: P, C, 1B, 2B, SS, 3B, LF, RF (no CF)
                positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'RF'];
                infieldPositions = ['1B', '2B', 'SS', '3B'];
                outfieldPositions = ['LF', 'RF'];
                playersPerInning = 8;
            } else {
                // 9+ players: standard 9 positions
                positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
                infieldPositions = ['1B', '2B', 'SS', '3B'];
                outfieldPositions = ['LF', 'CF', 'RF'];
                playersPerInning = 9;
            }
            
            const playersToBenchPerInning = numPlayers - playersPerInning;
            
            // Calculate targets including season stats
            // P and C are now considered "infield" positions
            const totalInfieldSlots = (infieldPositions.length + 2) * innings; // 36 infield slots (4 infield + 2 P/C)                                                                                                  
            const totalOutfieldSlots = outfieldPositions.length * innings; // 18 outfield slots
            const targetInfieldPerPlayer = Math.floor(totalInfieldSlots / numPlayers); // 4
            const targetOutfieldPerPlayer = Math.floor(totalOutfieldSlots / numPlayers); // 2
            
            // Calculate cumulative targets (including previous games)
            const gamesPlayed = Math.max(1, Math.max(...shuffledPlayers.map(p => seasonStats.playerStats[p.id]?.gamesPlayed || 0)));
            const cumulativeTargetInfield = targetInfieldPerPlayer * gamesPlayed;
            const cumulativeTargetOutfield = targetOutfieldPerPlayer * gamesPlayed;
            
            console.log(`Target balance: ${targetInfieldPerPlayer} infield (including P/C), ${targetOutfieldPerPlayer} outfield per player`);
            console.log(`Players: ${numPlayers}, Bench per inning: ${playersToBenchPerInning}`);
            
            // Initialize usage tracking
            const pitcherUsage = {};
            const catcherUsage = {};
            const playerUsage = {};
            const infieldUsage = {};
            const outfieldUsage = {};
            const positionUsage = {};
            const benchUsage = {};
            const lastPitcherInning = {};
            const lastCatcherInning = {};
            const lastOutfieldInning = {}; // Track last inning each player played outfield
            const outfieldPositionUsage = {}; // Track which outfield positions each player has played
            
            shuffledPlayers.forEach(player => {
                playerUsage[player.id] = 0;
                infieldUsage[player.id] = 0;
                outfieldUsage[player.id] = 0;
                benchUsage[player.id] = 0;
                positionUsage[player.id] = {};
                lastOutfieldInning[player.id] = 0; // Initialize outfield tracking
                outfieldPositionUsage[player.id] = { LF: 0, CF: 0, RF: 0 }; // Initialize outfield position tracking
                positions.forEach(pos => {
                    positionUsage[player.id][pos] = 0;
                });
                if (player.availablePositions.includes('P')) {
                    pitcherUsage[player.id] = 0;
                }
                if (player.availablePositions.includes('C')) {
                    catcherUsage[player.id] = 0;
                }
                lastCatcherInning[player.id] = 0;
            });
            
            // Dynamic setup based on actual available players
            if (numPlayers === 9) {
                console.log(`Perfect setup: ${numPlayers} players, ${playersPerInning} positions, no bench time!`);
            } else {
                console.log(`Setup: ${numPlayers} players, ${playersPerInning} positions, ${playersToBenchPerInning} players sit each inning`);
            }
            
            // Create bench schedule if we have more than 9 players
            let benchSchedule = [];
            if (numPlayers > 9) {
                // Create a balanced bench schedule with randomization
                const totalBenchSlots = playersToBenchPerInning * innings;
                const baseBenchInnings = Math.floor(totalBenchSlots / numPlayers);
                const extraBenchInnings = totalBenchSlots % numPlayers;
                
                const playerBenchCount = new Array(numPlayers).fill(0);
                
                for (let inning = 1; inning <= innings; inning++) {
                    const benchIndices = [];
                    const availableToBench = shuffledPlayers.map((p, index) => ({ player: p, index, benchCount: playerBenchCount[index] }));
                    
                    // Sort by bench count (players are already randomized from the shuffle)
                    availableToBench.sort((a, b) => a.benchCount - b.benchCount);
                    
                    for (let i = 0; i < playersToBenchPerInning && i < availableToBench.length; i++) {
                        benchIndices.push(availableToBench[i].index);
                        playerBenchCount[availableToBench[i].index]++;
                    }
                    benchSchedule.push(benchIndices);
                }
            }
            
            // Create a balanced rotation that ensures infield/outfield balance
            for (let inning = 1; inning <= innings; inning++) {
                const inningLineup = {};
                const usedPlayers = new Set(); // Track players used in this inning
                const benchedPlayers = new Set(); // Track players benched this inning
                
                // Add players who are benched this inning (if we have more than 9 players)
                if (numPlayers > 9 && benchSchedule.length > 0) {
                    const benchedThisInning = benchSchedule[inning - 1].map(index => shuffledPlayers[index]);
                    benchedThisInning.forEach(player => {
                        benchedPlayers.add(player.id);
                        benchUsage[player.id]++;
                    });
                }
                
                // Create a list of all positions to fill
                const positionsToFill = [...positions];
                
                // Assign positions one by one, ensuring no player gets multiple positions
                positionsToFill.forEach(pos => {
                    // Find available players for this position who haven't been used this inning and aren't benched
                    const availableForPos = shuffledPlayers.filter(p => 
                        p.availablePositions.includes(pos) && 
                        !usedPlayers.has(p.id) && 
                        !benchedPlayers.has(p.id)
                    );
                    
                    if (availableForPos.length > 0) {
                        let selectedPlayer;
                        
                        // Smart selection based on position type and balance
                        if (pos === 'P') {
                            // Check for manual pitcher selection first
                            const manualPitcherId = manualPitcherSelections[inning];
                            console.log(`Inning ${inning} - Manual pitcher ID:`, manualPitcherId);
                            console.log(`Available pitchers for inning ${inning}:`, availableForPos.map(p => `${p.name} (ID: ${p.id})`));
                            
                            if (manualPitcherId) {
                                // Use manually selected pitcher - override availability checks
                                const manualPitcher = gamePlayers.find(p => p.id == manualPitcherId);
                                if (manualPitcher) {
                                    selectedPlayer = manualPitcher;
                                    console.log(`Using manual pitcher: ${selectedPlayer.name} (inning ${inning}) - overriding availability checks`);
                                } else {
                                    console.log(`Manual pitcher ID ${manualPitcherId} not found in game players, falling back to automatic selection`);
                                    // Fall through to automatic selection
                                }
                            } else {
                                console.log(`No manual pitcher selected for inning ${inning}, using automatic selection`);
                            }
                            
                            // If no manual selection or manual pitcher not available, use automatic selection
                            if (!selectedPlayer) {
                                // For pitcher, prioritize 6 different pitchers (1 inning each) over consecutive innings
                                const availablePitchers = availableForPos.filter(p => p.availablePositions.includes('P'));                                                                                                  
                                
                                // First priority: Find pitchers who haven't pitched yet (for 6 different pitchers)
                                const unusedPitchers = availablePitchers.filter(p => pitcherUsage[p.id] === 0);
                                
                                if (unusedPitchers.length > 0) {
                                    // Use a pitcher who hasn't pitched yet (prefer 6 different pitchers)
                                    selectedPlayer = unusedPitchers[0];
                                    console.log(`Using new pitcher: ${selectedPlayer.name} (inning ${inning}) - prioritizing 6 different pitchers`);
                                } else {
                                // Second priority: If all pitchers have pitched, then use consecutive innings
                                const lastInningPitcher = lineup[inning - 2] ? lineup[inning - 2]['P'] : null;
                                const consecutivePitcher = availablePitchers.find(p => 
                                    p.name === lastInningPitcher && 
                                    pitcherUsage[p.id] < 2 // Haven't reached 2 innings yet
                                );
                                
                                if (consecutivePitcher) {
                                    // Use the same pitcher for consecutive innings
                                    selectedPlayer = consecutivePitcher;
                                    console.log(`Using consecutive pitcher: ${selectedPlayer.name} (inning ${inning}) - no unused pitchers available`);
                                } else {
                                    // Fallback: Find pitcher with lowest usage
                                    selectedPlayer = availablePitchers.reduce((best, current) => {
                                        return pitcherUsage[current.id] < pitcherUsage[best.id] ? current : best;
                                    });
                                }
                            }
                            }
                        } else if (pos === 'C') {
                            // For catcher, ensure no consecutive innings and rotate through available catchers
                            let availableCatchers = availableForPos.filter(p => p.availablePositions.includes('C'));
                            
                            // If we don't have enough designated catchers, allow any player to catch
                            if (availableCatchers.length < 3) {
                                console.log(`Only ${availableCatchers.length} designated catchers available, allowing any player to catch`);
                                availableCatchers = availableForPos; // Allow any available player
                            }
                            
                            // Find catchers who haven't caught consecutive innings
                            const lastInningCatcher = lineup[inning - 2] ? lineup[inning - 2]['C'] : null;
                            console.log(`Inning ${inning} - Last inning catcher: ${lastInningCatcher}`);
                            console.log(`Inning ${inning} - Current catcher usage:`, catcherUsage);
                            
                            const nonConsecutiveCatchers = availableCatchers.filter(p => 
                                p.name !== lastInningCatcher && 
                                (catcherUsage[p.id] || 0) < 1 // Haven't caught yet (1 inning max per catcher)
                            );
                            
                            console.log(`Inning ${inning} - Non-consecutive catchers:`, nonConsecutiveCatchers.map(p => `${p.name} (usage: ${catcherUsage[p.id] || 0})`));
                            
                            if (nonConsecutiveCatchers.length > 0) {
                                // Use a catcher who didn't catch last inning
                                selectedPlayer = nonConsecutiveCatchers[0];
                                console.log(`Using non-consecutive catcher: ${selectedPlayer.name} (inning ${inning})`);
                            console.log(`Catcher usage before assignment:`, catcherUsage);
                            } else {
                                // Improved fallback: prioritize catchers who haven't caught at all
                                const unusedCatchers = availableCatchers.filter(p => (catcherUsage[p.id] || 0) === 0);
                                if (unusedCatchers.length > 0) {
                                    selectedPlayer = unusedCatchers[0];
                                    console.log(`Using unused catcher: ${selectedPlayer.name} (inning ${inning})`);
                                } else {
                                    // Last resort: use any available catcher with lowest usage (but still respect 1-inning limit)
                                    const availableCatchers = availableForPos.filter(p => (catcherUsage[p.id] || 0) < 1);
                                    if (availableCatchers.length > 0) {
                                        selectedPlayer = availableCatchers[0];
                                        console.log(`Using fallback catcher: ${selectedPlayer.name} (inning ${inning})`);
                                    } else {
                                        // Emergency: no catchers available, use any player
                                        selectedPlayer = availableForPos[0];
                                        console.log(`Emergency catcher selection: ${selectedPlayer.name} (inning ${inning})`);
                                    }
                                }
                            }
                        } else if (infieldPositions.includes(pos) || pos === 'P' || pos === 'C') {
                            // For infield positions (including P and C), prioritize players with lower infield usage
                            selectedPlayer = availableForPos.reduce((best, current) => {
                                return infieldUsage[current.id] < infieldUsage[best.id] ? current : best;
                            });
                        } else if (outfieldPositions.includes(pos)) {
                            // For outfield positions, avoid consecutive outfield innings
                            const availableForOutfield = availableForPos.filter(p => 
                                lastOutfieldInning[p.id] !== inning - 1 // Not consecutive outfield
                            );
                            
                            if (availableForOutfield.length > 0) {
                                // Prioritize outfield position variety for players with multiple outfield innings
                                const playersWithMultipleOutfield = availableForOutfield.filter(p => outfieldUsage[p.id] > 1);
                                
                                if (playersWithMultipleOutfield.length > 0) {
                                    // For players with multiple outfield innings, prioritize those who haven't played this specific position
                                    const playersNotInThisPosition = playersWithMultipleOutfield.filter(p => 
                                        outfieldPositionUsage[p.id][pos] === 0
                                    );
                                    
                                    if (playersNotInThisPosition.length > 0) {
                                        selectedPlayer = playersNotInThisPosition.reduce((best, current) => {
                                            return outfieldUsage[current.id] < outfieldUsage[best.id] ? current : best;
                                        });
                                        console.log(`Using outfield position variety: ${selectedPlayer.name} for ${pos} (outfield innings: ${outfieldUsage[selectedPlayer.id]})`);
                                    } else {
                                        // Fallback to lowest outfield usage
                                        selectedPlayer = availableForOutfield.reduce((best, current) => {
                                            return outfieldUsage[current.id] < outfieldUsage[best.id] ? current : best;
                                        });
                                    }
                                } else {
                                    // Normal selection for players with 1 or fewer outfield innings
                                    selectedPlayer = availableForOutfield.reduce((best, current) => {
                                        return outfieldUsage[current.id] < outfieldUsage[best.id] ? current : best;
                                    });
                                }
                            } else {
                                // If all players played outfield last inning, fall back to lowest usage
                                selectedPlayer = availableForPos.reduce((best, current) => {
                                    return outfieldUsage[current.id] < outfieldUsage[best.id] ? current : best;
                                });
                            }
                        } else {
                            // Fallback: select player with lowest overall usage
                            selectedPlayer = availableForPos.reduce((best, current) => {
                                return playerUsage[current.id] < playerUsage[best.id] ? current : best;
                            });
                        }
                        
                        // Assign the selected player to this position
                        inningLineup[pos] = selectedPlayer.name;
                        usedPlayers.add(selectedPlayer.id);
                        playerUsage[selectedPlayer.id]++;
                        
                        // Update position-specific usage
                        if (pos === 'P') {
                            pitcherUsage[selectedPlayer.id]++;
                            infieldUsage[selectedPlayer.id]++; // P counts as infield
                        } else if (pos === 'C') {
                            catcherUsage[selectedPlayer.id]++; // Track catcher usage
                            console.log(`Catcher usage after assignment:`, catcherUsage);
                            infieldUsage[selectedPlayer.id]++; // C counts as infield
                        } else if (infieldPositions.includes(pos)) {
                            infieldUsage[selectedPlayer.id]++;
                        } else if (outfieldPositions.includes(pos)) {
                            outfieldUsage[selectedPlayer.id]++;
                            lastOutfieldInning[selectedPlayer.id] = inning; // Track last outfield inning
                            outfieldPositionUsage[selectedPlayer.id][pos]++; // Track specific outfield position usage
                        }
                        positionUsage[selectedPlayer.id][pos]++;
                        
                        console.log(`Inning ${inning} - ${selectedPlayer.name} assigned to ${pos}`);
                    }
                });
                
                // Store this inning's lineup
                lineup[inning - 1] = { ...inningLineup };
                
                // Display inning lineup
                lineupHTML += `<div class="inning"><h4>Inning ${inning}</h4>`;
                lineupHTML += '<div class="lineup-section">';
                lineupHTML += '<h5>Fielding:</h5>';
                positions.forEach(pos => {
                    if (inningLineup[pos]) {
                        lineupHTML += `<div class="position-row"><span class="position">${pos}</span><span class="player">${inningLineup[pos]}</span></div>`;
                    }
                });
                lineupHTML += '</div>';
                
                // Show bench if we have more than 9 players
                if (numPlayers > 9 && benchedPlayers.size > 0) {
                    const benchPlayers = shuffledPlayers.filter(p => benchedPlayers.has(p.id));
                    lineupHTML += '<div class="bench-section">';
                    lineupHTML += '<h5>Bench:</h5>';
                    benchPlayers.forEach(player => {
                        lineupHTML += `<div class="bench-player">${player.name}</div>`;
                    });
                    lineupHTML += '</div>';
                }
                
                lineupHTML += '</div>';
                
                console.log(`Inning ${inning} lineup:`, inningLineup);
                console.log(`Inning ${inning} used players:`, Array.from(usedPlayers).map(id => shuffledPlayers.find(p => p.id === id).name));
            }
            
            // Add usage statistics
            lineupHTML += `
                <div style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px;">
                    <h4>Playing Time Summary:</h4>
                    <p style="font-size: 0.9rem; color: #6b7280; margin-bottom: 15px;">
                        ${numPlayers === 9 ? 
                            `Perfect setup: ${numPlayers} players, 9 positions, no bench time needed! Each player plays all 6 innings.` :
                            `Setup: ${numPlayers} players, 9 positions, ${playersToBenchPerInning} players sit each inning.`
                        }
                        <br><strong>Target Balance:</strong> ${targetInfieldPerPlayer} infield (including P/C), ${targetOutfieldPerPlayer} outfield per player.
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
            `;
            
            // Use game players for summary display (not shuffled)
            gamePlayers.forEach(player => {
                // Count actual innings played and bench time
                const actualInningsPlayed = playerUsage[player.id];
                const actualBenchTime = benchUsage[player.id] || 0;
                const totalInnings = actualInningsPlayed + actualBenchTime;
                const expectedTotal = 6; // Each player should be involved in all 6 innings
                
                // Debug: Log each player's actual usage
                console.log(`${player.name}: ${actualInningsPlayed} playing, ${actualBenchTime} bench, infield: ${infieldUsage[player.id]}, outfield: ${outfieldUsage[player.id]}`);
                
                const infieldBalance = Math.abs(infieldUsage[player.id] - targetInfieldPerPlayer);
                const outfieldBalance = Math.abs(outfieldUsage[player.id] - targetOutfieldPerPlayer);
                const isBalanced = infieldBalance <= 1 && outfieldBalance <= 1;
                const isComplete = totalInnings === expectedTotal;
                
                lineupHTML += `
                    <div style="font-size: 0.9rem; padding: 8px; border-radius: 4px; background: ${isComplete && isBalanced ? '#f0f9ff' : '#fef2f2'};">
                        <strong>${player.name}:</strong> ${actualInningsPlayed} playing, ${actualBenchTime} bench
                        <br><small>(Infield: ${infieldUsage[player.id]}/${targetInfieldPerPlayer}, Outfield: ${outfieldUsage[player.id]}/${targetOutfieldPerPlayer})</small>
                        ${!isBalanced ? '<br><small style="color: #dc2626;">⚠️ Unbalanced!</small>' : ''}
                        ${!isComplete ? '<br><small style="color: #dc2626;">⚠️ Missing innings!</small>' : ''}
                    </div>
                `;
            });
            
            lineupHTML += `
                    </div>
                </div>
                <p><strong>Features:</strong></p>
                <ul>
                    <li>✅ All pitchers get equal opportunities</li>
                    <li>✅ Balanced infield/outfield time for each player</li>
                    <li>✅ Only designated catchers play catcher</li>
                    <li>✅ Maximum 1 inning per position per player</li>
                    <li>✅ Shows who's on the bench each inning</li>
                    <li>✅ Tries to minimize bench time (ideally 1 inning per player)</li>
                    <li>✅ Respects player position preferences</li>
                </ul>
            `;
            
            console.log('=== generateSmartLineup COMPLETE ===');
            console.log('Final lineup array:', lineup);
            console.log('Final lineup HTML length:', lineupHTML.length);
            return lineupHTML;
        }
        
        function toggleAllPositions() {
            const allCheckbox = document.getElementById('pos-All');
            const isChecked = allCheckbox.checked;
            
            // Get all position checkboxes except the "All" checkbox
            const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
            positions.forEach(pos => {
                const checkbox = document.getElementById(`pos-${pos}`);
                if (checkbox) {
                    checkbox.checked = isChecked;
                }
            });
        }
        
        function updateAllCheckbox() {
            const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
            const allCheckbox = document.getElementById('pos-All');
            
            // Check if all individual position checkboxes are checked
            const allChecked = positions.every(pos => {
                const checkbox = document.getElementById(`pos-${pos}`);
                return checkbox && checkbox.checked;
            });
            
            // Update the "All" checkbox state
            allCheckbox.checked = allChecked;
        }
        
        function updateDashboardStats() {
            const totalPlayers = players.length;
            const totalPitchers = players.filter(p => p.availablePositions.includes('P')).length;
            const totalCatchers = players.filter(p => p.availablePositions.includes('C')).length;
            
            // Calculate wins and losses
            let totalWins = 0;
            let totalLosses = 0;
            
            games.forEach(game => {
                if (game.ourScore !== undefined && game.opponentScore !== undefined) {
                    if (game.ourScore > game.opponentScore) {
                        totalWins++;
                    } else if (game.ourScore < game.opponentScore) {
                        totalLosses++;
                    }
                    // Ties don't count as wins or losses
                }
            });
            
            document.getElementById('totalPlayers').textContent = totalPlayers;
            document.getElementById('totalPitchers').textContent = totalPitchers;
            document.getElementById('totalCatchers').textContent = totalCatchers;
            document.getElementById('totalWins').textContent = totalWins;
            document.getElementById('totalLosses').textContent = totalLosses;
        }
        
        // Game management functions
        function loadGames() {
            const savedGames = localStorage.getItem(getStorageKey('games'));
            if (savedGames) {
                games = JSON.parse(savedGames);
                nextGameId = Math.max(...games.map(g => g.id)) + 1;
            } else {
                // Restore default games for kimner team
                if (currentTeamCode === 'kimner') {
                    games = [
                        {
                            id: 1,
                            opponent: 'Quandt',
                            date: '2025-09-28',
                            innings: 6,
                            availablePlayers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            ourScore: '',
                            opponentScore: ''
                        },
                        {
                            id: 2,
                            opponent: 'Lightning Strikes',
                            date: '2025-10-05',
                            innings: 6,
                            availablePlayers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            ourScore: '',
                            opponentScore: ''
                        },
                        {
                            id: 3,
                            opponent: 'Thunder Bolts',
                            date: '2025-10-12',
                            innings: 6,
                            availablePlayers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            ourScore: '',
                            opponentScore: ''
                        },
                        {
                            id: 4,
                            opponent: 'Eagles',
                            date: '2025-10-19',
                            innings: 6,
                            availablePlayers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            ourScore: '',
                            opponentScore: ''
                        }
                    ];
                    nextGameId = 5;
                    saveGames();
                } else {
                    games = [];
                    nextGameId = 1;
                }
            }
        }
        
        async function saveGames() {
            localStorage.setItem(getStorageKey('games'), JSON.stringify(games));
            if (!safeMode) {
                await saveToFirebase(); // Also save to cloud
            }
        }
        
        function renderGamePlayerCheckboxes() {
            const container = document.getElementById('gamePlayerCheckboxes');
            container.innerHTML = '';
            
            players.forEach(player => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'position-checkbox';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="game-player-${player.id}" checked>
                    <label for="game-player-${player.id}">${player.name}</label>
                `;
                container.appendChild(checkboxDiv);
            });
        }
        
        function addGame() {
            const opponent = document.getElementById('gameOpponent').value.trim();
            const date = document.getElementById('gameDate').value;
            const innings = parseInt(document.getElementById('gameInnings').value);
            const ourScore = document.getElementById('ourScore').value ? parseInt(document.getElementById('ourScore').value) : undefined;
            const opponentScore = document.getElementById('opponentScore').value ? parseInt(document.getElementById('opponentScore').value) : undefined;
            
            if (!opponent || !date) {
                alert('Please fill in opponent and date');
                return;
            }
            
            const availablePlayers = [];
            players.forEach(player => {
                const checkbox = document.getElementById(`game-player-${player.id}`);
                if (checkbox && checkbox.checked) {
                    availablePlayers.push(player.id);
                }
            });
            
            if (availablePlayers.length < 9) {
                alert('Need at least 9 players available for a game');
                return;
            }
            
            // Add new game
            const newGame = {
                id: nextGameId++,
                opponent: opponent,
                date: date,
                innings: innings,
                ourScore: ourScore,
                opponentScore: opponentScore,
                availablePlayers: availablePlayers
            };
            games.push(newGame);
            
            saveGames();
            hideAddGameForm();
            renderGames();
            updateDashboardStats();
        }
        
        function clearGameForm() {
            document.getElementById('gameOpponent').value = '';
            document.getElementById('gameDate').value = '';
            document.getElementById('gameInnings').value = '6';
            document.getElementById('ourScore').value = '';
            document.getElementById('opponentScore').value = '';
            
            // Check all players by default
            players.forEach(player => {
                const checkbox = document.getElementById(`game-player-${player.id}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            // Reset form state
            document.querySelector('#addGameForm h3').textContent = 'Add New Game';
            document.querySelector('#addGameForm .btn-success').textContent = 'Add Game';
            document.querySelector('#addGameForm .btn-secondary').textContent = 'Clear Form';
        }
        
        function renderGames() {
            const gamesList = document.getElementById('gamesList');
            if (!gamesList) return;
            
            gamesList.innerHTML = '';
            
            if (games.length === 0) {
                gamesList.innerHTML = '<p>No games scheduled yet. Add a game above!</p>';
                return;
            }
            
            games.forEach(game => {
                const gameCard = document.createElement('div');
                gameCard.className = 'player-card';
                gameCard.style.cssText = 'cursor: pointer; transition: all 0.2s ease;';
                gameCard.onclick = () => openGameDetail(game.id);
                gameCard.onmouseover = () => gameCard.style.borderColor = '#2563eb';
                gameCard.onmouseout = () => gameCard.style.borderColor = '#e5e7eb';
                
                const availablePlayerNames = game.availablePlayers.map(playerId => 
                    players.find(p => p.id === playerId)?.name || 'Unknown'
                ).join(', ');
                
                const statusIcons = [];
                if (game.generatedLineup) statusIcons.push('⚾');
                if (game.battingOrder) statusIcons.push('🏏');
                
                const scoreText = game.ourScore !== undefined && game.opponentScore !== undefined 
                    ? `${game.ourScore} - ${game.opponentScore}`
                    : 'Not played yet';
                
                const resultIcon = game.ourScore !== undefined && game.opponentScore !== undefined
                    ? (game.ourScore > game.opponentScore ? '🏆' : 
                       game.ourScore < game.opponentScore ? '😞' : '🤝')
                    : '';
                
                gameCard.innerHTML = `
                    <div class="player-info">
                        <h4>vs ${game.opponent} ${statusIcons.join(' ')} ${resultIcon}</h4>
                        <p><strong>Date:</strong> ${new Date(game.date).toLocaleDateString()}</p>
                        <p><strong>Innings:</strong> ${game.innings}</p>
                        <p><strong>Score:</strong> ${scoreText}</p>
                        <p><strong>Available Players:</strong> ${game.availablePlayers.length} (${availablePlayerNames})</p>
                    </div>
                    <div class="player-actions">
                        <button class="btn btn-sm btn-secondary" onclick="event.stopPropagation(); openGameDetail(${game.id})">Edit Game Details</button>
                        <button class="btn btn-sm" onclick="event.stopPropagation(); openGameStats(${game.id})" style="background: #7c3aed; color: white; margin-left: 8px;">📊 Track Game</button>
                    </div>
                `;
                
                gamesList.appendChild(gameCard);
            });
            
            // Update the quick game selector
            updateQuickGameSelector();
            // Update the batting game selector
            updateBattingGameSelector();
        }
        
        function updateQuickGameSelector() {
            const selector = document.getElementById('quickGameSelect');
            if (!selector) return;
            
            // Keep the "All Players Available" option
            const allOption = selector.querySelector('option[value="all"]');
            selector.innerHTML = '';
            selector.appendChild(allOption);
            
            // Add game options (most recent first)
            const sortedGames = [...games].sort((a, b) => new Date(b.date) - new Date(a.date));
            sortedGames.forEach(game => {
                const option = document.createElement('option');
                option.value = game.id;
                option.textContent = `vs ${game.opponent} (${new Date(game.date).toLocaleDateString()})`;
                selector.appendChild(option);
            });
        }
        
        async function generateQuickLineup() {
            const selectedGameId = document.getElementById('quickGameSelect').value;
            
            if (selectedGameId === 'all') {
                // Generate lineup with all players
                generateLineup();
            } else {
                // Generate lineup for specific game
                await generateLineupForGame(parseInt(selectedGameId));
            }
            
            // Switch to lineup tab to show results
            showSection('lineup');
        }
        
        // Batting Order Functions
        let currentBattingGame = null;
        let battingOrder = [];
        let currentGameDetail = null;
        let originalGameState = null; // Track original state for change detection
        
        function updateBattingGameSelector() {
            const selector = document.getElementById('battingGameSelect');
            if (!selector) return;
            
            selector.innerHTML = '<option value="">Choose a game...</option>';
            
            games.forEach(game => {
                const option = document.createElement('option');
                option.value = game.id;
                option.textContent = `vs ${game.opponent} (${new Date(game.date).toLocaleDateString()})`;
                selector.appendChild(option);
            });
        }
        
        function selectBattingGame() {
            const gameId = document.getElementById('battingGameSelect').value;
            const container = document.getElementById('battingOrderContainer');
            
            if (!gameId) {
                container.style.display = 'none';
                return;
            }
            
            currentBattingGame = games.find(g => g.id === parseInt(gameId));
            if (!currentBattingGame) return;
            
            container.style.display = 'block';
            renderBattingOrderInterface();
        }
        
        function renderBattingOrderInterface() {
            if (!currentBattingGame) {
                return;
            }
            
            // Get available players for this game (filter out any invalid player IDs)
            const availablePlayers = players.filter(p => 
                currentBattingGame.availablePlayers.includes(p.id)
            );
            
            // Clean up the game's availablePlayers array to remove any invalid player IDs
            const originalLength = currentBattingGame.availablePlayers.length;
            currentBattingGame.availablePlayers = currentBattingGame.availablePlayers.filter(playerId => 
                players.some(p => p.id === playerId)
            );
            
            // If we cleaned up invalid player IDs, save the game
            if (currentBattingGame.availablePlayers.length !== originalLength) {
                console.log(`Cleaned up ${originalLength - currentBattingGame.availablePlayers.length} invalid player IDs from game`);
                saveGames(); // Save the cleaned up game data
            }
            
            // Load existing batting order or initialize empty with correct number of slots                                                                
            const numSlots = availablePlayers.length;
            
            console.log('Batting order debug:', {
                gameAvailablePlayers: currentBattingGame.availablePlayers.length,
                validPlayers: availablePlayers.length,
                numSlots: numSlots,
                playerNames: availablePlayers.map(p => p.name)
            });
            
            // Only reset batting order if it's empty or wrong length
            if (!battingOrder || battingOrder.length !== numSlots) {
                battingOrder = currentBattingGame.battingOrder || new Array(numSlots).fill(null);
            }
            
            // Update title to show number of slots
            const title = document.getElementById('battingOrderTitle');
            if (title) {
                title.textContent = `Batting Order (1-${numSlots})`;
            }
            
            renderAvailablePlayers(availablePlayers);
            renderBattingOrderSlots();
        }
        
        function renderAvailablePlayers(availablePlayers) {
            const container = document.getElementById('availablePlayers');
            container.innerHTML = '';
            
            // Filter out players who are already in the batting order
            const availableForBatting = availablePlayers.filter(player => 
                !battingOrder.includes(player.id)
            );
            
            // Always show the available players area, even if empty
            if (availableForBatting.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.style.cssText = 'color: #9ca3af; font-style: italic; text-align: center; padding: 20px; border: 2px dashed #cbd5e1; border-radius: 8px; background: #f8fafc;';
                emptyMessage.textContent = 'Drag players here to remove from batting order';
                container.appendChild(emptyMessage);
            } else {
                availableForBatting.forEach(player => {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'player-item';
                    playerItem.draggable = true;
                    playerItem.dataset.playerId = player.id;
                    playerItem.textContent = player.name;
                    
                    // Add drag event listeners
                    playerItem.addEventListener('dragstart', handleDragStart);
                    playerItem.addEventListener('dragend', handleDragEnd);
                    
                    container.appendChild(playerItem);
                });
            }
            
            // Add drop event listeners to the container for removing players from batting order
            container.addEventListener('dragover', handleDragOver);
            container.addEventListener('drop', handleDrop);
            container.addEventListener('dragenter', handleDragEnter);
            container.addEventListener('dragleave', handleDragLeave);
        }
        
        function renderBattingOrderSlots() {
            const container = document.getElementById('battingOrder');
            container.innerHTML = '';
            
            for (let i = 0; i < battingOrder.length; i++) {
                const slot = document.createElement('div');
                slot.className = 'batting-slot';
                slot.dataset.slotIndex = i;
                
                if (battingOrder[i]) {
                    const player = players.find(p => p.id === battingOrder[i]);
                    slot.innerHTML = `
                        <div>
                            <div class="batting-slot-number">${i + 1}</div>
                            <div>${player ? player.name : 'Unknown'}</div>
                        </div>
                    `;
                    slot.classList.add('occupied');
                    // Make occupied slots draggable for reordering
                    slot.draggable = true;
                    slot.dataset.playerId = battingOrder[i];
                } else {
                    slot.innerHTML = `
                        <div>
                            <div class="batting-slot-number">${i + 1}</div>
                            <div style="color: #9ca3af;">Drop player here</div>
                        </div>
                    `;
                    slot.draggable = false;
                }
                
                // Add drop event listeners
                slot.addEventListener('dragover', handleDragOver);
                slot.addEventListener('drop', handleDrop);
                slot.addEventListener('dragenter', handleDragEnter);
                slot.addEventListener('dragleave', handleDragLeave);
                
                // Add drag event listeners for reordering
                slot.addEventListener('dragstart', handleDragStart);
                slot.addEventListener('dragend', handleDragEnd);
                
                container.appendChild(slot);
            }
        }
        
        // Drag and Drop Event Handlers
        function handleDragStart(e) {
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            // Handle both player items and batting order slots
            const playerId = e.target.dataset.playerId;
            e.dataTransfer.setData('text/plain', playerId);
            
            // Store the source type (player-item or batting-slot)
            e.dataTransfer.setData('text/source', e.target.classList.contains('player-item') ? 'player-item' : 'batting-slot');
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function handleDragEnter(e) {
            // Find the actual slot element (might be a child element)
            let slotElement = e.target;
            while (slotElement && !slotElement.classList.contains('batting-slot')) {
                slotElement = slotElement.parentElement;
            }
            
            if (slotElement) {
                slotElement.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            // Find the actual slot element (might be a child element)
            let slotElement = e.target;
            while (slotElement && !slotElement.classList.contains('batting-slot')) {
                slotElement = slotElement.parentElement;
            }
            
            if (slotElement) {
                slotElement.classList.remove('drag-over');
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const playerId = parseInt(e.dataTransfer.getData('text/plain'));
            const sourceType = e.dataTransfer.getData('text/source');
            
            // Check if dropping on available players area (to remove from batting order)
            if (e.target.id === 'availablePlayers' || e.target.closest('#availablePlayers')) {
                // Remove player from batting order
                const existingSlot = battingOrder.findIndex(id => id === playerId);
                if (existingSlot !== -1) {
                    battingOrder[existingSlot] = null;
                    renderBattingOrderInterface();
                }
                return;
            }
            
            // Find the actual slot element (might be a child element)
            let slotElement = e.target;
            while (slotElement && !slotElement.classList.contains('batting-slot')) {
                slotElement = slotElement.parentElement;
            }
            
            if (!slotElement) {
                return;
            }
            
            const slotIndex = parseInt(slotElement.dataset.slotIndex);
            
            if (playerId && slotIndex >= 0 && slotIndex < battingOrder.length) {
                // If dragging from one batting slot to another, swap the players
                if (sourceType === 'batting-slot' && battingOrder[slotIndex]) {
                    // Find the source slot
                    const sourceSlot = battingOrder.findIndex(id => id === playerId);
                    if (sourceSlot !== -1) {
                        // Swap the players
                        const targetPlayerId = battingOrder[slotIndex];
                        battingOrder[sourceSlot] = targetPlayerId;
                        battingOrder[slotIndex] = playerId;
                    }
                } else {
                    // Normal drop: remove from existing slot and add to new slot
                    const existingSlot = battingOrder.findIndex(id => id === playerId);
                    if (existingSlot !== -1) {
                        battingOrder[existingSlot] = null;
                    }
                    
                    // Add player to new slot
                    battingOrder[slotIndex] = playerId;
                }
                
                // Re-render the interface
                renderBattingOrderInterface();
            }
        }
        
        function saveBattingOrder() {
            if (!currentBattingGame) return;
            
            currentBattingGame.battingOrder = [...battingOrder];
            saveGames();
            alert('Batting order saved!');
        }
        
        function autoGenerateBattingOrder() {
            if (!currentBattingGame) return;
            
            const availablePlayers = players.filter(p => 
                currentBattingGame.availablePlayers.includes(p.id)
            );
            
            // Simple auto-generation: shuffle available players
            const shuffled = [...availablePlayers].sort(() => Math.random() - 0.5);
            
            battingOrder = new Array(availablePlayers.length).fill(null);
            for (let i = 0; i < shuffled.length; i++) {
                battingOrder[i] = shuffled[i].id;
            }
            
            renderBattingOrderInterface();
        }
        
        function printLineupCard() {
            if (!currentBattingGame) {
                alert('Please select a game first');
                return;
            }
            
            // Generate printable lineup card
            const lineupCard = generatePrintableLineupCard();
            
            // Create new window for printing
            const printWindow = window.open('', '_blank');
            printWindow.document.write(lineupCard);
            printWindow.document.close();
            printWindow.print();
        }
        
        function generatePrintableLineupCard() {
            const game = currentBattingGame;
            const battingOrderNames = battingOrder.map(playerId => {
                const player = players.find(p => p.id === playerId);
                return player ? player.name : '';
            });
            
            // Get the defensive lineup if it exists
            let defensiveLineupHTML = '';
            if (game.generatedLineup && game.generatedLineup.innings) {
                defensiveLineupHTML = `
                    <div class="defensive-lineup">
                        <h3>Defensive Positions</h3>
                        <table class="defensive-table">
                            <thead>
                                <tr>
                                    <th>Inning</th>
                                    <th>P</th>
                                    <th>C</th>
                                    <th>1B</th>
                                    <th>2B</th>
                                    <th>SS</th>
                                    <th>3B</th>
                                    <th>LF</th>
                                    <th>CF</th>
                                    <th>RF</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${game.generatedLineup.innings.map((inning, index) => `
                                    <tr>
                                        <td class="inning-num">${index + 1}</td>
                                        <td>${inning.P || 'TBD'}</td>
                                        <td>${inning.C || 'TBD'}</td>
                                        <td>${inning['1B'] || 'TBD'}</td>
                                        <td>${inning['2B'] || 'TBD'}</td>
                                        <td>${inning.SS || 'TBD'}</td>
                                        <td>${inning['3B'] || 'TBD'}</td>
                                        <td>${inning.LF || 'TBD'}</td>
                                        <td>${inning.CF || 'TBD'}</td>
                                        <td>${inning.RF || 'TBD'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } else {
                defensiveLineupHTML = `
                    <div class="defensive-lineup">
                        <h3>Defensive Positions</h3>
                        <p><em>Generate defensive lineup first to see positions per inning</em></p>
                    </div>
                `;
            }
            
            return `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Lineup Card - vs ${game.opponent}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 10px; font-size: 12px; }
                        .lineup-card { border: 2px solid #000; padding: 15px; }
                        .header { text-align: center; margin-bottom: 15px; }
                        .header h1 { margin: 0; font-size: 18px; }
                        .header h2 { margin: 5px 0; font-size: 16px; }
                        .header p { margin: 5px 0; font-size: 12px; }
                        .batting-order { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin-bottom: 15px; }
                        .batting-slot { border: 1px solid #000; padding: 5px; text-align: center; }
                        .slot-number { font-weight: bold; font-size: 10px; }
                        .defensive-lineup { margin-top: 10px; }
                        .defensive-lineup h3 { margin: 0 0 8px 0; font-size: 14px; }
                        .defensive-table { width: 100%; border-collapse: collapse; font-size: 10px; }
                        .defensive-table th, .defensive-table td { border: 1px solid #000; padding: 2px; text-align: center; }
                        .defensive-table th { background-color: #f0f0f0; font-weight: bold; }
                        .inning-num { font-weight: bold; }
                        @media print {
                            body { margin: 5px; }
                            .lineup-card { padding: 10px; }
                        }
                    </style>
                </head>
                <body>
                    <div class="lineup-card">
                        <div class="header">
                            <h1>Lineup Card</h1>
                            <h2>vs ${game.opponent}</h2>
                            <p><strong>Date:</strong> ${new Date(game.date).toLocaleDateString()}</p>
                        </div>
                        
                        <div class="batting-order">
                            ${battingOrderNames.map((name, index) => `
                                <div class="batting-slot">
                                    <div class="slot-number">${index + 1}</div>
                                    <div>${name || 'TBD'}</div>
                                </div>
                            `).join('')}
                        </div>
                        
                        ${defensiveLineupHTML}
                    </div>
                </body>
                </html>
            `;
        }
        
        function deleteGame(gameId) {
            if (confirm('Are you sure you want to delete this game?')) {
                games = games.filter(g => g.id !== gameId);
                saveGames();
                renderGames();
            }
        }
        
        async function generateLineupForGame(gameId) {
            console.log('generateLineupForGame called with gameId:', gameId);
            const game = games.find(g => g.id === gameId);
            console.log('Found game:', game);
            if (!game) {
                console.log('No game found, returning');
                alert('Error: Game not found. Please try again.');
                return;
            }
            
            // Load season stats for cumulative balancing
            loadSeasonStats();
            
            // Filter players to only those available for this game
            const availablePlayers = players.filter(p => game.availablePlayers.includes(p.id));
            console.log('Available players for game:', availablePlayers);
            console.log('Total players in roster:', players.length);
            console.log('Game available players:', game.availablePlayers);
            
            if (availablePlayers.length < 8) {
                alert(`You need at least 8 players available for this game. Currently have ${availablePlayers.length} players available out of ${players.length} total players. Make sure to check the player availability boxes when adding the game.`);                                                                                       
                return;
            }
            
            const pitchers = availablePlayers.filter(p => p.availablePositions.includes('P'));
            console.log('Available pitchers:', pitchers);
            if (pitchers.length === 0) {
                alert('You need at least one pitcher available for this game to generate a lineup. Make sure at least one player has "P" (Pitcher) in their available positions.');
                return;
            }
            
            // Generate lineup using available players
            console.log('Calling generateSmartLineup...');
            console.log('Available players for lineup:', availablePlayers.length);
            console.log('Current game detail:', currentGameDetail);
            
            let generatedLineup;
            try {
                generatedLineup = generateSmartLineup(availablePlayers, gameId);
                console.log('Generated lineup HTML:', generatedLineup);
                console.log('Global lineup array:', lineup);
                
                if (!generatedLineup) {
                    console.error('generateSmartLineup returned null/undefined');
                    alert('Error: Lineup generation failed. Check console for details.');
                    return;
                }
            } catch (error) {
                console.error('Error in generateSmartLineup:', error);
                alert('Error generating lineup: ' + error.message);
                return;
            }
            
            // Save the generated lineup to the game
            game.generatedLineup = {
                timestamp: new Date().toISOString(),
                innings: [...lineup] // Copy the current lineup
            };
            console.log('Saved lineup to game:', game.generatedLineup);
            
            // Update season stats with this game's lineup
            updateSeasonStats(lineup);
            
            // Save games to localStorage
            await saveGames();
            console.log('Games saved to localStorage');
            
            // Verify the lineup was saved
            const savedGame = games.find(g => g.id === gameId);
            if (savedGame && savedGame.generatedLineup) {
                console.log('✅ Lineup successfully saved and verified');
            } else {
                console.error('❌ Lineup save verification failed');
            }
            
            // No need to restore players array since we didn't modify it
            
            // Update the lineup display in the game detail view
            const lineupDisplay = document.getElementById('lineup-display');
            console.log('Lineup display element:', lineupDisplay);
            if (lineupDisplay) {
                lineupDisplay.innerHTML = generatedLineup;
                console.log('Updated lineup display');
            }
            
            // Show success message
            alert(`Lineup generated and saved for vs ${game.opponent}!`);
        }
        
        function viewSavedLineup(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game || !game.generatedLineup) {
                alert('No saved lineup found for this game');
                return;
            }
            
            console.log('Displaying saved lineup for game:', gameId);
            console.log('Saved lineup data:', game.generatedLineup.innings);
            
            // Display the saved lineup directly without regenerating
            const lineupHTML = displaySavedLineup(game.generatedLineup.innings, game.availablePlayers);
            
            // Update the lineup display in the current view
            const lineupDisplay = document.getElementById('lineup-display');
            console.log('Lineup display element:', lineupDisplay);
            if (lineupDisplay) {
                lineupDisplay.innerHTML = lineupHTML;
                console.log('Updated lineup display with saved lineup');
            } else {
                console.log('Lineup display element not found!');
            }
        }
        
        function displaySavedLineup(savedInnings, availablePlayerIds) {
            if (!savedInnings || savedInnings.length === 0) {
                return '<p style="color: #6b7280;">No lineup data found.</p>';
            }
            
            // Get the opponent name from the current game
            const game = games.find(g => g.id === currentGameDetail?.id);
            const opponentName = game ? game.opponent : (currentGameDetail ? currentGameDetail.opponent : 'Opponent');
            const innings = savedInnings.length;
            
            let html = `<h3>Kimner vs ${opponentName} - ${innings} Innings</h3>`;
            
            savedInnings.forEach((inning, index) => {
                html += `<div class="inning"><h4>Inning ${index + 1}</h4>`;
                html += '<div class="lineup-section">';
                html += '<h5>Fielding:</h5>';
                
                // Display positions in the same order as the original
                const positions = ['P', 'C', '1B', '2B', 'SS', '3B', 'LF', 'CF', 'RF'];
                positions.forEach(pos => {
                    if (inning[pos]) {
                        html += `<div class="position-row"><span class="position">${pos}</span><span class="player">${inning[pos]}</span></div>`;
                    }
                });
                
                html += '</div>';
                html += '</div>';
            });
            
            return html;
        }
        
        function clearSavedLineupNote() {
            const noteElement = document.getElementById('savedLineupNote');
            if (noteElement) {
                noteElement.remove();
            }
        }
        
        // Game Detail Functions
        function openGameDetail(gameId) {
            console.log('openGameDetail called with gameId:', gameId);
            console.log('Available games:', games);
            currentGameDetail = games.find(g => g.id === gameId);
            console.log('Found currentGameDetail:', currentGameDetail);
            if (!currentGameDetail) {
                console.log('No currentGameDetail found, returning');
                return;
            }
            
            // Capture original state for change detection
            originalGameState = {
                opponent: currentGameDetail.opponent,
                date: currentGameDetail.date,
                innings: currentGameDetail.innings,
                ourScore: currentGameDetail.ourScore || '',
                opponentScore: currentGameDetail.opponentScore || '',
                availablePlayers: [...currentGameDetail.availablePlayers] // Copy array
            };
            
            // Set current batting game to this game
            currentBattingGame = currentGameDetail;
            console.log('Set currentBattingGame to:', currentBattingGame);
            
            // Update game detail title
            document.getElementById('gameDetailTitle').textContent = `vs ${currentGameDetail.opponent}`;
            
            // Populate edit form
            populateEditForm();
            
            // Render game info
            renderGameInfo();
            
            // Clear lineup display for new game
            clearLineupDisplay();
            
            // Render batting order interface
            renderBattingOrderInterface();
            
            // Update save button text
            updateSaveButtonText();
            
            // Add event listeners to form fields for change detection
            addChangeDetectionListeners();
            
            // Switch to game detail view
            showSection('gameDetail');
        }
        
        function populateEditForm() {
            if (!currentGameDetail) return;
            
            // Populate the edit form with current game data
            document.getElementById('editGameOpponent').value = currentGameDetail.opponent;
            document.getElementById('editGameDate').value = currentGameDetail.date;
            document.getElementById('editGameInnings').value = currentGameDetail.innings;
            document.getElementById('editOurScore').value = currentGameDetail.ourScore || '';
            document.getElementById('editOpponentScore').value = currentGameDetail.opponentScore || '';
            
            // Populate player checkboxes
            renderEditGamePlayerCheckboxes();
        }
        
        function renderEditGamePlayerCheckboxes() {
            const container = document.getElementById('editGamePlayerCheckboxes');
            if (!container) return;
            
            container.innerHTML = '';
            
            players.forEach(player => {
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'position-checkbox';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="edit-game-player-${player.id}" 
                           ${currentGameDetail.availablePlayers.includes(player.id) ? 'checked' : ''}
                           data-player-id="${player.id}">
                    <label for="edit-game-player-${player.id}">${player.name}</label>
                `;
                container.appendChild(checkboxDiv);
            });
        }
        
        function updateGameFromDetail() {
            if (!currentGameDetail) return;
            
            const opponent = document.getElementById('editGameOpponent').value.trim();
            const date = document.getElementById('editGameDate').value;
            const innings = parseInt(document.getElementById('editGameInnings').value);
            const ourScore = document.getElementById('editOurScore').value ? parseInt(document.getElementById('editOurScore').value) : undefined;
            const opponentScore = document.getElementById('editOpponentScore').value ? parseInt(document.getElementById('editOpponentScore').value) : undefined;
            
            if (!opponent || !date) {
                alert('Please fill in opponent and date');
                return;
            }
            
            const availablePlayers = [];
            players.forEach(player => {
                const checkbox = document.getElementById(`edit-game-player-${player.id}`);
                if (checkbox && checkbox.checked) {
                    availablePlayers.push(player.id);
                }
            });
            
            if (availablePlayers.length < 9) {
                alert('Need at least 9 players available for a game');
                return;
            }
            
            // Update the current game
            const gameIndex = games.findIndex(g => g.id === currentGameDetail.id);
            if (gameIndex !== -1) {
                games[gameIndex] = {
                    ...games[gameIndex],
                    opponent: opponent,
                    date: date,
                    innings: innings,
                    ourScore: ourScore,
                    opponentScore: opponentScore,
                    availablePlayers: availablePlayers
                };
                
                // Update current game detail reference
                currentGameDetail = games[gameIndex];
                currentBattingGame = currentGameDetail;
            }
            
            saveGames();
            renderGameInfo();
            renderBattingOrderInterface();
            updateDashboardStats();
            
            // Update original state to current state after saving
            originalGameState = {
                opponent: opponent,
                date: date,
                innings: innings,
                ourScore: ourScore || '',
                opponentScore: opponentScore || '',
                availablePlayers: [...availablePlayers]
            };
            
            // Update save button text
            updateSaveButtonText();
            
            // Refresh the schedule view to show updated information
            renderGames();
            
            alert('Game updated successfully!');
        }
        
        function goBackToSchedule() {
            // Check if there are unsaved changes
            const hasChanges = detectChanges();
            
            if (hasChanges) {
                // Ask for confirmation if there are unsaved changes
                if (confirm('You have unsaved changes. Are you sure you want to go back? Your changes will be lost.')) {
                    showSection('schedule');
                    renderGames(); // Refresh the schedule view
                }
            } else {
                // No changes, just go back to schedule
                showSection('schedule');
                renderGames(); // Refresh the schedule view
            }
        }
        
        function addChangeDetectionListeners() {
            // Add event listeners to all form fields
            const formFields = [
                'editGameOpponent',
                'editGameDate', 
                'editGameInnings',
                'editOurScore',
                'editOpponentScore'
            ];
            
            formFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', updateSaveButtonText);
                    field.addEventListener('change', updateSaveButtonText);
                }
            });
            
            // Add listeners to player checkboxes
            const checkboxes = document.querySelectorAll('#editGamePlayerCheckboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', updateSaveButtonText);
            });
        }
        
        function updateSaveButtonText() {
            const saveButton = document.querySelector('button[onclick="updateGameFromDetail()"]');
            if (!saveButton) return;
            
            const hasChanges = detectChanges();
            if (hasChanges) {
                saveButton.textContent = 'Save Changes';
                saveButton.classList.remove('btn-secondary');
                saveButton.classList.add('btn-success');
            } else {
                saveButton.textContent = 'Save';
                saveButton.classList.remove('btn-success');
                saveButton.classList.add('btn-secondary');
            }
        }
        
        function detectChanges() {
            if (!originalGameState) return false;
            
            // Check basic form fields
            const currentState = {
                opponent: document.getElementById('editGameOpponent').value,
                date: document.getElementById('editGameDate').value,
                innings: parseInt(document.getElementById('editGameInnings').value),
                ourScore: document.getElementById('editOurScore').value,
                opponentScore: document.getElementById('editOpponentScore').value,
                availablePlayers: []
            };
            
            // Check player availability
            const checkboxes = document.querySelectorAll('#editGamePlayerCheckboxes input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    currentState.availablePlayers.push(parseInt(checkbox.dataset.playerId));
                }
            });
            
            // Compare with original state
            return (
                currentState.opponent !== originalGameState.opponent ||
                currentState.date !== originalGameState.date ||
                currentState.innings !== originalGameState.innings ||
                currentState.ourScore !== originalGameState.ourScore ||
                currentState.opponentScore !== originalGameState.opponentScore ||
                !arraysEqual(currentState.availablePlayers.sort(), originalGameState.availablePlayers.sort())
            );
        }
        
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        
        function clearLineupDisplay() {
            const lineupDisplay = document.getElementById('lineup-display');
            if (lineupDisplay) {
                if (currentGameDetail && currentGameDetail.generatedLineup) {
                    // If this game has a saved lineup, show it
                    viewSavedLineup(currentGameDetail.id);
                } else {
                    // Otherwise, show the default message
                    lineupDisplay.innerHTML = '<p style="color: #6b7280;">Click "Generate Defensive Lineup" to create position rotations for this game.</p>';
                }
            }
        }
        
        // Generate lineups for all future games
        async function generateFutureLineups() {
            console.log('=== GENERATING FUTURE LINEUPS ===');
            
            // Check if we have players
            if (players.length === 0) {
                alert('Please add your team roster first before generating lineups. Go to the Players tab to add players.');
                return;
            }
            
            // Check if we have games
            if (games.length === 0) {
                alert('Please add games to your schedule first.');
                return;
            }
            
            // Get current date
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time to start of day
            
            // Find future games (all games with dates in the future, regardless of existing lineups)
            const futureGames = games.filter(game => {
                const gameDate = new Date(game.date);
                gameDate.setHours(0, 0, 0, 0);
                return gameDate >= today;
            });
            
            console.log('Found future games:', futureGames.length);
            
            if (futureGames.length === 0) {
                alert('No future games found. Add games with future dates to your schedule first.');
                return;
            }
            
            // Show confirmation
            const gameList = futureGames.map(g => {
                const hasLineup = g.generatedLineup ? ' (will regenerate)' : ' (new lineup)';
                return `• vs ${g.opponent} (${new Date(g.date).toLocaleDateString()})${hasLineup}`;
            }).join('\n');
            
            if (!confirm(`Regenerate lineups for ${futureGames.length} future games?\n\n${gameList}\n\nThis will update all future lineups based on current player capabilities and season balance.`)) {
                return;
            }
            
            // Generate lineups for each future game
            let successCount = 0;
            let errorCount = 0;
            const results = [];
            
            for (const game of futureGames) {
                try {
                    console.log(`Generating lineup for game vs ${game.opponent}`);
                    
                    // Temporarily set currentGameDetail for lineup generation
                    const originalGameDetail = currentGameDetail;
                    currentGameDetail = game;
                    
                    // Generate lineup for this game
                    await generateLineupForGame(game.id);
                    
                    // Restore original game detail
                    currentGameDetail = originalGameDetail;
                    
                    successCount++;
                    results.push(`✅ vs ${game.opponent} - Lineup generated`);
                    
                } catch (error) {
                    console.error(`Error generating lineup for game vs ${game.opponent}:`, error);
                    errorCount++;
                    results.push(`❌ vs ${game.opponent} - Error: ${error.message}`);
                }
            }
            
            // Show results
            const resultMessage = `Future Lineup Generation Complete!\n\n✅ Success: ${successCount} games\n❌ Errors: ${errorCount} games\n\n${results.join('\n')}`;
            alert(resultMessage);
            
            // Refresh the games display
            renderGames();
            
            console.log('=== FUTURE LINEUP GENERATION COMPLETE ===');
        }
        
        function renderGameInfo() {
            if (!currentGameDetail) return;
            
            const availablePlayerNames = currentGameDetail.availablePlayers
                .map(id => players.find(p => p.id === id)?.name)
                .filter(name => name)
                .join(', ');
            
            const gameInfo = document.getElementById('gameInfo');
            const scoreText = currentGameDetail.ourScore !== undefined && currentGameDetail.opponentScore !== undefined 
                ? `${currentGameDetail.ourScore} - ${currentGameDetail.opponentScore}`
                : 'Not played yet';
            
            const resultText = currentGameDetail.ourScore !== undefined && currentGameDetail.opponentScore !== undefined
                ? (currentGameDetail.ourScore > currentGameDetail.opponentScore ? '🏆 WIN' : 
                   currentGameDetail.ourScore < currentGameDetail.opponentScore ? '😞 LOSS' : '🤝 TIE')
                : '';
            
            gameInfo.innerHTML = `
                <h3>Game Information</h3>
                <p><strong>Opponent:</strong> ${currentGameDetail.opponent}</p>
                <p><strong>Date:</strong> ${new Date(currentGameDetail.date).toLocaleDateString()}</p>
                <p><strong>Innings:</strong> ${currentGameDetail.innings}</p>
                <p><strong>Final Score:</strong> ${scoreText} ${resultText}</p>
                <p><strong>Available Players:</strong> ${currentGameDetail.availablePlayers.length} (${availablePlayerNames})</p>
                <p><strong>Status:</strong> ${currentGameDetail.generatedLineup ? '✅ Defensive lineup generated' : '⏳ No defensive lineup yet'}</p>
                <p><strong>Batting Order:</strong> ${currentGameDetail.battingOrder ? '✅ Batting order set' : '⏳ No batting order yet'}</p>
            `;
        }
        
        // Manual Pitcher Selection Functions
        function toggleManualPitcherSelection() {
            const toggle = document.getElementById('manualPitcherToggle');
            const controls = document.getElementById('manualPitcherControls');
            const dropdowns = document.getElementById('pitcherDropdowns');
            
            if (toggle.checked) {
                controls.style.display = 'block';
                generatePitcherDropdowns();
            } else {
                controls.style.display = 'none';
                manualPitcherSelections = {};
            }
        }
        
        function generatePitcherDropdowns() {
            const dropdowns = document.getElementById('pitcherDropdowns');
            dropdowns.innerHTML = '';
            
            // Get available pitchers for current game
            const availablePitchers = getAvailablePitchersForCurrentGame();
            
            // Create dropdowns for 6 innings
            for (let inning = 1; inning <= 6; inning++) {
                const inningDiv = document.createElement('div');
                inningDiv.style.display = 'flex';
                inningDiv.style.flexDirection = 'column';
                inningDiv.style.gap = '5px';
                
                const label = document.createElement('label');
                label.textContent = `Inning ${inning}:`;
                label.style.fontWeight = 'bold';
                label.style.fontSize = '14px';
                
                const select = document.createElement('select');
                select.id = `pitcherInning${inning}`;
                select.style.padding = '5px';
                select.style.border = '1px solid #ccc';
                select.style.borderRadius = '3px';
                select.onchange = () => validatePitcherSelections();
                
                // Add empty option for automatic selection
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = 'Auto';
                select.appendChild(emptyOption);
                
                // Add pitcher options
                availablePitchers.forEach(pitcher => {
                    const option = document.createElement('option');
                    option.value = pitcher.id;
                    option.textContent = pitcher.name;
                    select.appendChild(option);
                });
                
                inningDiv.appendChild(label);
                inningDiv.appendChild(select);
                dropdowns.appendChild(inningDiv);
            }
        }
        
        function getAvailablePitchersForCurrentGame() {
            if (!currentGameDetail) return [];
            
            const availablePlayers = players.filter(p => 
                currentGameDetail.availablePlayers.includes(p.id) && 
                p.availablePositions.includes('P')
            );
            
            return availablePlayers;
        }
        
        function validatePitcherSelections() {
            const validation = document.getElementById('pitcherValidation');
            const selectedPitchers = {};
            const duplicates = [];
            
            // Collect all selections
            for (let inning = 1; inning <= 6; inning++) {
                const select = document.getElementById(`pitcherInning${inning}`);
                if (select) {
                    const selectedId = select.value;
                    console.log(`Inning ${inning} dropdown value:`, selectedId);
                    
                    if (selectedId) {
                        if (selectedPitchers[inning]) {
                            // Check if this player is already selected for another inning
                            const existingInning = Object.keys(selectedPitchers).find(inn => selectedPitchers[inn] == selectedId);
                            if (existingInning) {
                                duplicates.push(selectedId);
                            }
                        }
                        selectedPitchers[inning] = selectedId;
                    }
                }
            }
            
            // Update global selections
            manualPitcherSelections = selectedPitchers;
            console.log('Updated manualPitcherSelections:', manualPitcherSelections);
            
            // Show validation message
            if (duplicates.length > 0) {
                const duplicateNames = duplicates.map(id => players.find(p => p.id == id)?.name).join(', ');
                validation.innerHTML = `<span style="color: #dc2626;">⚠️ Warning: ${duplicateNames} selected multiple times</span>`;
            } else if (Object.keys(selectedPitchers).length > 0) {
                const selectedCount = Object.keys(selectedPitchers).length;
                validation.innerHTML = `<span style="color: #059669;">✅ ${selectedCount} pitcher(s) manually selected</span>`;
            } else {
                validation.innerHTML = '';
            }
        }

        async function generateLineupForCurrentGame() {
            console.log('=== BUTTON CLICKED ===');
            console.log('generateLineupForCurrentGame called, currentGameDetail:', currentGameDetail);
            
            // Update manual pitcher selections before generating lineup
            const toggle = document.getElementById('manualPitcherToggle');
            if (toggle && toggle.checked) {
                console.log('Manual pitcher mode enabled, updating selections...');
                validatePitcherSelections();
            }
            
            // Debug manual pitcher selections
            console.log('Manual pitcher selections:', manualPitcherSelections);
            console.log('Manual pitcher toggle checked:', toggle ? toggle.checked : 'toggle not found');
            
            if (!currentGameDetail) {
                console.log('No currentGameDetail, returning');
                alert('Error: No game selected. Please select a game from the Games tab first.');
                return;
            }
            console.log('Generating lineup for game ID:', currentGameDetail.id);
            await generateLineupForGame(currentGameDetail.id);
        }
        
        function viewSavedLineupForCurrentGame() {
            console.log('viewSavedLineupForCurrentGame called, currentGameDetail:', currentGameDetail);
            if (!currentGameDetail) {
                alert('No game selected. Please select a game first.');
                return;
            }
            viewSavedLineup(currentGameDetail.id);
        }
        
        function printLineupCardForCurrentGame() {
            if (!currentGameDetail) return;
            printLineupCard();
        }
        
        // Add Game Form Functions
        function showAddGameForm() {
            // Check if there are any players in the roster
            if (players.length === 0) {
                alert('Please add your team roster first before scheduling games. Go to the Players tab to add players.');
                return;
            }
            
            document.getElementById('addGameForm').style.display = 'block';
            document.getElementById('showAddGameBtn').style.display = 'none';
            // Set today's date as default
            document.getElementById('gameDate').value = new Date().toISOString().split('T')[0];
        }
        
        function hideAddGameForm() {
            document.getElementById('addGameForm').style.display = 'none';
            document.getElementById('showAddGameBtn').style.display = 'inline-block';
            clearGameForm();
        }
        
        
        function deleteGameFromDetail() {
            if (!currentGameDetail) return;
            
            if (confirm(`Are you sure you want to delete the game vs ${currentGameDetail.opponent}? This will also delete any saved lineups and batting orders for this game.`)) {
                deleteGame(currentGameDetail.id);
                showSection('schedule');
            }
        }
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, JavaScript is working');
            testJS(); // Test function
            
            // Add emergency debug button
            addEmergencyDebugButton();
            
            // Add error handling
            window.addEventListener('error', function(e) {
                console.error('🚨 JAVASCRIPT ERROR:', e.error);
                console.error('Error details:', e.filename, e.lineno, e.colno);
                alert('JavaScript Error: ' + e.message + '\nCheck console for details.');
            });
            
            // Add player protection monitoring
            setInterval(() => {
                protectPlayerArray();
            }, 1000); // Check every second
            
            setInterval(() => {
                checkPlayerArray();
            }, 2000); // Check for changes every 2 seconds
            
            try {
                // Initialize team first
                initializeTeam();
                
                loadPlayers(); // Load saved players from localStorage
                loadGames(); // Load saved games from localStorage
                loadSeasonStats(); // Load season stats for cumulative balancing
            } catch (error) {
                console.error('🚨 INITIALIZATION ERROR:', error);
                alert('App initialization failed: ' + error.message);
            }
            renderPlayers();
            renderGames();
            renderGamePlayerCheckboxes();
            updateDashboardStats(); // Update dashboard statistics
        });
    </script>
    
    <!-- Game Stats Modal -->
    <div id="gameStatsModal" class="game-stats-modal" style="display: none;">
        <div class="game-stats-content">
            <div class="game-stats-header">
                <h2>📊 Game Stats Tracker</h2>
                <button class="close-stats-btn" onclick="closeGameStats()">✕</button>
            </div>
            
            <!-- Scoreboard -->
            <div id="scoreboard" class="scoreboard">
                <div class="scoreboard-content">
                    <div class="score-display">
                        <div class="team-score">
                            <div class="score-number">0</div>
                            <div class="team-name">Home</div>
                        </div>
                        <div class="vs">-</div>
                        <div class="team-score">
                            <div class="score-number">0</div>
                            <div class="team-name">Away</div>
                        </div>
                    </div>
                    <div class="game-info">
                        <span>Inning: 1</span>
                        <span>Outs: 0</span>
                        <span>Status: scheduled</span>
                    </div>
                </div>
            </div>
            
            <!-- Game Controls -->
            <div class="stats-controls">
                <!-- Start Game Button (shown when scheduled) -->
                <div id="startGameSection" style="display: block;">
                    <button class="action-btn btn-start" onclick="startGame()">
                        🏟️ Start Game
                    </button>
                </div>
                
                <!-- In-Game Controls (shown when in-progress) -->
                <div id="inGameSection" style="display: none;">
                    <!-- Player Selectors -->
                    <div class="player-selectors">
                        <div class="player-selector">
                            <label>Current Batter:</label>
                            <select id="currentBatterSelect" onchange="setCurrentBatter(this.value)">
                                <option value="">Select Batter</option>
                            </select>
                        </div>
                        <div class="player-selector">
                            <label>Current Pitcher:</label>
                            <select id="currentPitcherSelect" onchange="setCurrentPitcher(this.value)">
                                <option value="">Select Pitcher</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="action-buttons">
                        <button class="action-btn btn-hit" onclick="recordHit('single')">Single</button>
                        <button class="action-btn btn-hit" onclick="recordHit('double')">Double</button>
                        <button class="action-btn btn-hit" onclick="recordHit('triple')">Triple</button>
                        <button class="action-btn btn-hit" onclick="recordHit('home-run')">Home Run</button>
                        <button class="action-btn btn-out" onclick="recordOut('strikeout')">Strikeout</button>
                        <button class="action-btn btn-out" onclick="recordOut('groundout')">Groundout</button>
                        <button class="action-btn btn-out" onclick="recordOut('flyout')">Flyout</button>
                        <button class="action-btn btn-walk" onclick="recordWalk('walk')">Walk</button>
                    </div>
                    
                    <!-- Detailed Pitch Tracking -->
                    <div style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <h4 style="margin: 0 0 15px 0; color: #1e293b; font-size: 16px;">🎯 Pitch Tracking</h4>
                        <div class="action-buttons">
                            <button class="action-btn btn-pitch" onclick="addPitch()">Pitch (+1)</button>
                            <button class="action-btn" onclick="addStrike()" style="background: #10b981; color: white;">Strike</button>
                            <button class="action-btn" onclick="addBall()" style="background: #f59e0b; color: white;">Ball</button>
                            <button class="action-btn" onclick="subtractPitch()" style="background: #ef4444; color: white;">-1 Pitch</button>
                        </div>
                    </div>
                    
                    <!-- Batter Stats -->
                    <div style="margin-top: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px; border: 1px solid #0ea5e9;">
                        <h4 style="margin: 0 0 15px 0; color: #0c4a6e; font-size: 16px;">⚾ Batter Stats</h4>
                        <div class="action-buttons">
                            <button class="action-btn" onclick="recordBatterStat('stolenBase')" style="background: #8b5cf6; color: white;">Stolen Base</button>
                            <button class="action-btn" onclick="recordBatterStat('rbi')" style="background: #06b6d4; color: white;">RBI</button>
                            <button class="action-btn" onclick="recordBatterStat('run')" style="background: #84cc16; color: white;">Run</button>
                        </div>
                    </div>
                    
                    <!-- Current Pitcher Stats -->
                    <div id="currentPitcherStats" class="pitcher-stats" style="display: none;">
                        <h4 id="currentPitcherName">Pitcher Stats</h4>
                        <div class="pitcher-stats-grid">
                            <div class="stat-item">
                                <div class="stat-label">Pitches</div>
                                <div class="stat-value" id="pitcherPitches">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Strikeouts</div>
                                <div class="stat-value" id="pitcherStrikeouts">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Walks</div>
                                <div class="stat-value" id="pitcherWalks">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-label">Hits Allowed</div>
                                <div class="stat-value" id="pitcherHits">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  </body>
</html>
